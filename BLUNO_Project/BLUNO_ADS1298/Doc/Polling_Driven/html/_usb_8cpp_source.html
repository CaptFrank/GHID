<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ADS1298_BLE_Sensor_Polling_Driven: /Volumes/DataHDD/Documents/Development Projects/GHID - Beta/GHID/BLUNO_Project/BLUNO_ADS1298/Src/Polling_Driven/Main/GHID_Framework/Src/Included Libraries/USB_Host_Shield_2.0-master/Usb.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ADS1298_BLE_Sensor_Polling_Driven
   &#160;<span id="projectnumber">ver2.0</span>
   </div>
   <div id="projectbrief">A Sensor node made of the ADS1298 polling driven</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/Volumes/DataHDD/Documents/Development Projects/GHID - Beta/GHID/BLUNO_Project/BLUNO_ADS1298/Src/Polling_Driven/Main/GHID_Framework/Src/Included Libraries/USB_Host_Shield_2.0-master/Usb.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_usb_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Copyright (C) 2011 Circuits At Home, LTD. All rights reserved.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">This software may be distributed and modified under the terms of the GNU</span>
<a name="l00004"></a>00004 <span class="comment">General Public License version 2 (GPL2) as published by the Free Software</span>
<a name="l00005"></a>00005 <span class="comment">Foundation and appearing in the file GPL2.TXT included in the packaging of</span>
<a name="l00006"></a>00006 <span class="comment">this file. Please note that GPL2 Section 2[b] requires that all works based</span>
<a name="l00007"></a>00007 <span class="comment">on this software must also be made publicly available under the terms of</span>
<a name="l00008"></a>00008 <span class="comment">the GPL2 (&quot;Copyleft&quot;).</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">Contact information</span>
<a name="l00011"></a>00011 <span class="comment">-------------------</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">Circuits At Home, LTD</span>
<a name="l00014"></a>00014 <span class="comment">Web      :  http://www.circuitsathome.com</span>
<a name="l00015"></a>00015 <span class="comment">e-mail   :  support@circuitsathome.com</span>
<a name="l00016"></a>00016 <span class="comment"> */</span>
<a name="l00017"></a>00017 <span class="comment">/* USB functions */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="_usb_8h.html">Usb.h</a>&quot;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="keyword">static</span> uint8_t usb_error = 0;
<a name="l00022"></a>00022 <span class="keyword">static</span> uint8_t usb_task_state;
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="comment">/* constructor */</span>
<a name="l00025"></a>00025 USB::USB() : bmHubPre(0) {
<a name="l00026"></a>00026         usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE; <span class="comment">//set up state machine</span>
<a name="l00027"></a>00027         init();
<a name="l00028"></a>00028 }
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="comment">/* Initialize data structures */</span>
<a name="l00031"></a>00031 <span class="keywordtype">void</span> USB::init() {
<a name="l00032"></a>00032         <span class="comment">//devConfigIndex = 0;</span>
<a name="l00033"></a>00033         bmHubPre = 0;
<a name="l00034"></a>00034 }
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 uint8_t USB::getUsbTaskState(<span class="keywordtype">void</span>) {
<a name="l00037"></a>00037         <span class="keywordflow">return</span> ( usb_task_state);
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keywordtype">void</span> USB::setUsbTaskState(uint8_t <a class="code" href="_mouse___chronos_8cpp.html#a2db8c09b4598a5b457667c34a46f311e">state</a>) {
<a name="l00041"></a>00041         usb_task_state = <a class="code" href="_mouse___chronos_8cpp.html#a2db8c09b4598a5b457667c34a46f311e">state</a>;
<a name="l00042"></a>00042 }
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 EpInfo* USB::getEpInfoEntry(uint8_t addr, uint8_t ep) {
<a name="l00045"></a>00045         UsbDevice *p = addrPool.GetUsbDevicePtr(addr);
<a name="l00046"></a>00046 
<a name="l00047"></a>00047         <span class="keywordflow">if</span>(!p || !p-&gt;epinfo)
<a name="l00048"></a>00048                 <span class="keywordflow">return</span> NULL;
<a name="l00049"></a>00049 
<a name="l00050"></a>00050         EpInfo *pep = p-&gt;epinfo;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052         <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; p-&gt;epcount; i++) {
<a name="l00053"></a>00053                 <span class="keywordflow">if</span>((pep)-&gt;epAddr == ep)
<a name="l00054"></a>00054                         <span class="keywordflow">return</span> pep;
<a name="l00055"></a>00055 
<a name="l00056"></a>00056                 pep++;
<a name="l00057"></a>00057         }
<a name="l00058"></a>00058         <span class="keywordflow">return</span> NULL;
<a name="l00059"></a>00059 }
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 <span class="comment">/* set device table entry */</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">/* each device is different and has different number of endpoints. This function plugs endpoint record structure, defined in application, to devtable */</span>
<a name="l00064"></a>00064 uint8_t USB::setEpInfoEntry(uint8_t addr, uint8_t epcount, EpInfo* eprecord_ptr) {
<a name="l00065"></a>00065         <span class="keywordflow">if</span>(!eprecord_ptr)
<a name="l00066"></a>00066                 <span class="keywordflow">return</span> USB_ERROR_INVALID_ARGUMENT;
<a name="l00067"></a>00067 
<a name="l00068"></a>00068         UsbDevice *p = addrPool.GetUsbDevicePtr(addr);
<a name="l00069"></a>00069 
<a name="l00070"></a>00070         <span class="keywordflow">if</span>(!p)
<a name="l00071"></a>00071                 <span class="keywordflow">return</span> USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073         p-&gt;address.devAddress = addr;
<a name="l00074"></a>00074         p-&gt;epinfo = eprecord_ptr;
<a name="l00075"></a>00075         p-&gt;epcount = epcount;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077         <span class="keywordflow">return</span> 0;
<a name="l00078"></a>00078 }
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 uint8_t USB::SetAddress(uint8_t addr, uint8_t ep, EpInfo **ppep, uint16_t &amp;nak_limit) {
<a name="l00081"></a>00081         UsbDevice *p = addrPool.GetUsbDevicePtr(addr);
<a name="l00082"></a>00082 
<a name="l00083"></a>00083         <span class="keywordflow">if</span>(!p)
<a name="l00084"></a>00084                 <span class="keywordflow">return</span> USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
<a name="l00085"></a>00085 
<a name="l00086"></a>00086         <span class="keywordflow">if</span>(!p-&gt;epinfo)
<a name="l00087"></a>00087                 <span class="keywordflow">return</span> USB_ERROR_EPINFO_IS_NULL;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089         *ppep = getEpInfoEntry(addr, ep);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091         <span class="keywordflow">if</span>(!*ppep)
<a name="l00092"></a>00092                 <span class="keywordflow">return</span> USB_ERROR_EP_NOT_FOUND_IN_TBL;
<a name="l00093"></a>00093 
<a name="l00094"></a>00094         nak_limit = (0x0001UL &lt;&lt; (((*ppep)-&gt;bmNakPower &gt; USB_NAK_MAX_POWER) ? USB_NAK_MAX_POWER : (*ppep)-&gt;bmNakPower));
<a name="l00095"></a>00095         nak_limit--;
<a name="l00096"></a>00096         <span class="comment">/*</span>
<a name="l00097"></a>00097 <span class="comment">          USBTRACE2(&quot;\r\nAddress: &quot;, addr);</span>
<a name="l00098"></a>00098 <span class="comment">          USBTRACE2(&quot; EP: &quot;, ep);</span>
<a name="l00099"></a>00099 <span class="comment">          USBTRACE2(&quot; NAK Power: &quot;,(*ppep)-&gt;bmNakPower);</span>
<a name="l00100"></a>00100 <span class="comment">          USBTRACE2(&quot; NAK Limit: &quot;, nak_limit);</span>
<a name="l00101"></a>00101 <span class="comment">          USBTRACE(&quot;\r\n&quot;);</span>
<a name="l00102"></a>00102 <span class="comment">         */</span>
<a name="l00103"></a>00103         regWr(rPERADDR, addr); <span class="comment">//set peripheral address</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105         uint8_t mode = regRd(rMODE);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107         <span class="comment">//Serial.print(&quot;\r\nMode: &quot;);</span>
<a name="l00108"></a>00108         <span class="comment">//Serial.println( mode, HEX);</span>
<a name="l00109"></a>00109         <span class="comment">//Serial.print(&quot;\r\nLS: &quot;);</span>
<a name="l00110"></a>00110         <span class="comment">//Serial.println(p-&gt;lowspeed, HEX);</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 
<a name="l00114"></a>00114         <span class="comment">// Set bmLOWSPEED and bmHUBPRE in case of low-speed device, reset them otherwise</span>
<a name="l00115"></a>00115         regWr(rMODE, (p-&gt;lowspeed) ? mode | bmLOWSPEED | bmHubPre : mode &amp; ~(bmHUBPRE | bmLOWSPEED));
<a name="l00116"></a>00116 
<a name="l00117"></a>00117         <span class="keywordflow">return</span> 0;
<a name="l00118"></a>00118 }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="comment">/* Control transfer. Sets address, endpoint, fills control packet with necessary data, dispatches control packet, and initiates bulk IN transfer,   */</span>
<a name="l00121"></a>00121 <span class="comment">/* depending on request. Actual requests are defined as inlines                                                                                      */</span>
<a name="l00122"></a>00122 <span class="comment">/* return codes:                */</span>
<a name="l00123"></a>00123 <span class="comment">/* 00       =   success         */</span>
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">/* 01-0f    =   non-zero HRSLT  */</span>
<a name="l00126"></a>00126 uint8_t USB::ctrlReq(uint8_t addr, uint8_t ep, uint8_t bmReqType, uint8_t bRequest, uint8_t wValLo, uint8_t wValHi,
<a name="l00127"></a>00127         uint16_t wInd, uint16_t total, uint16_t nbytes, uint8_t* dataptr, USBReadParser *p) {
<a name="l00128"></a>00128         <span class="keywordtype">bool</span> direction = <span class="keyword">false</span>; <span class="comment">//request direction, IN or OUT</span>
<a name="l00129"></a>00129         uint8_t rcode;
<a name="l00130"></a>00130         SETUP_PKT setup_pkt;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132         EpInfo *pep = NULL;
<a name="l00133"></a>00133         uint16_t nak_limit = 0;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         rcode = SetAddress(addr, ep, &amp;pep, nak_limit);
<a name="l00136"></a>00136 
<a name="l00137"></a>00137         <span class="keywordflow">if</span>(rcode)
<a name="l00138"></a>00138                 <span class="keywordflow">return</span> rcode;
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         direction = ((bmReqType &amp; 0x80) &gt; 0);
<a name="l00141"></a>00141 
<a name="l00142"></a>00142         <span class="comment">/* fill in setup packet */</span>
<a name="l00143"></a>00143         setup_pkt.ReqType_u.bmRequestType = bmReqType;
<a name="l00144"></a>00144         setup_pkt.bRequest = bRequest;
<a name="l00145"></a>00145         setup_pkt.wVal_u.wValueLo = wValLo;
<a name="l00146"></a>00146         setup_pkt.wVal_u.wValueHi = wValHi;
<a name="l00147"></a>00147         setup_pkt.wIndex = wInd;
<a name="l00148"></a>00148         setup_pkt.wLength = total;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150         bytesWr(rSUDFIFO, 8, (uint8_t*) &amp; setup_pkt); <span class="comment">//transfer to setup packet FIFO</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152         rcode = dispatchPkt(tokSETUP, ep, nak_limit); <span class="comment">//dispatch packet</span>
<a name="l00153"></a>00153 
<a name="l00154"></a>00154         <span class="keywordflow">if</span>(rcode) <span class="comment">//return HRSLT if not zero</span>
<a name="l00155"></a>00155                 <span class="keywordflow">return</span> ( rcode);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157         <span class="keywordflow">if</span>(dataptr != NULL) <span class="comment">//data stage, if present</span>
<a name="l00158"></a>00158         {
<a name="l00159"></a>00159                 <span class="keywordflow">if</span>(direction) <span class="comment">//IN transfer</span>
<a name="l00160"></a>00160                 {
<a name="l00161"></a>00161                         uint16_t left = total;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163                         pep-&gt;bmRcvToggle = 1; <span class="comment">//bmRCVTOG1;</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165                         <span class="keywordflow">while</span>(left) {
<a name="l00166"></a>00166                                 <span class="comment">// Bytes read into buffer</span>
<a name="l00167"></a>00167                                 uint16_t read = nbytes;
<a name="l00168"></a>00168                                 <span class="comment">//uint16_t read = (left&lt;nbytes) ? left : nbytes;</span>
<a name="l00169"></a>00169 
<a name="l00170"></a>00170                                 rcode = InTransfer(pep, nak_limit, &amp;read, dataptr);
<a name="l00171"></a>00171                                 <span class="keywordflow">if</span>(rcode == hrTOGERR) {
<a name="l00172"></a>00172                                         <span class="comment">// yes, we flip it wrong here so that next time it is actually correct!</span>
<a name="l00173"></a>00173                                         pep-&gt;bmRcvToggle = (regRd(rHRSL) &amp; bmSNDTOGRD) ? 0 : 1;
<a name="l00174"></a>00174                                         <span class="keywordflow">continue</span>;
<a name="l00175"></a>00175                                 }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177                                 <span class="keywordflow">if</span>(rcode)
<a name="l00178"></a>00178                                         <span class="keywordflow">return</span> rcode;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180                                 <span class="comment">// Invoke callback function if inTransfer completed successfully and callback function pointer is specified</span>
<a name="l00181"></a>00181                                 <span class="keywordflow">if</span>(!rcode &amp;&amp; p)
<a name="l00182"></a>00182                                         ((USBReadParser*)p)-&gt;Parse(read, dataptr, total - left);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184                                 left -= read;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186                                 <span class="keywordflow">if</span>(read &lt; nbytes)
<a name="l00187"></a>00187                                         <span class="keywordflow">break</span>;
<a name="l00188"></a>00188                         }
<a name="l00189"></a>00189                 } <span class="keywordflow">else</span> <span class="comment">//OUT transfer</span>
<a name="l00190"></a>00190                 {
<a name="l00191"></a>00191                         pep-&gt;bmSndToggle = 1; <span class="comment">//bmSNDTOG1;</span>
<a name="l00192"></a>00192                         rcode = OutTransfer(pep, nak_limit, nbytes, dataptr);
<a name="l00193"></a>00193                 }
<a name="l00194"></a>00194                 <span class="keywordflow">if</span>(rcode) <span class="comment">//return error</span>
<a name="l00195"></a>00195                         <span class="keywordflow">return</span> ( rcode);
<a name="l00196"></a>00196         }
<a name="l00197"></a>00197         <span class="comment">// Status stage</span>
<a name="l00198"></a>00198         <span class="keywordflow">return</span> dispatchPkt((direction) ? tokOUTHS : tokINHS, ep, nak_limit); <span class="comment">//GET if direction</span>
<a name="l00199"></a>00199 }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="comment">/* IN transfer to arbitrary endpoint. Assumes PERADDR is set. Handles multiple packets if necessary. Transfers &#39;nbytes&#39; bytes. */</span>
<a name="l00202"></a>00202 <span class="comment">/* Keep sending INs and writes data to memory area pointed by &#39;data&#39;                                                           */</span>
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/* rcode 0 if no errors. rcode 01-0f is relayed from dispatchPkt(). Rcode f0 means RCVDAVIRQ error,</span>
<a name="l00205"></a>00205 <span class="comment">            fe USB xfer timeout */</span>
<a name="l00206"></a>00206 uint8_t USB::inTransfer(uint8_t addr, uint8_t ep, uint16_t *nbytesptr, uint8_t* <a class="code" href="masstorage_8h.html#afb87d045bbf32b236fc425efe02bdc7b">data</a>) {
<a name="l00207"></a>00207         EpInfo *pep = NULL;
<a name="l00208"></a>00208         uint16_t nak_limit = 0;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         uint8_t rcode = SetAddress(addr, ep, &amp;pep, nak_limit);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212         <span class="keywordflow">if</span>(rcode) {
<a name="l00213"></a>00213                 USBTRACE3(<span class="stringliteral">&quot;(USB::InTransfer) SetAddress Failed &quot;</span>, rcode, 0x81);
<a name="l00214"></a>00214                 USBTRACE3(<span class="stringliteral">&quot;(USB::InTransfer) addr requested &quot;</span>, addr, 0x81);
<a name="l00215"></a>00215                 USBTRACE3(<span class="stringliteral">&quot;(USB::InTransfer) ep requested &quot;</span>, ep, 0x81);
<a name="l00216"></a>00216                 <span class="keywordflow">return</span> rcode;
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218         <span class="keywordflow">return</span> InTransfer(pep, nak_limit, nbytesptr, data);
<a name="l00219"></a>00219 }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221 uint8_t USB::InTransfer(EpInfo *pep, uint16_t nak_limit, uint16_t *nbytesptr, uint8_t* data) {
<a name="l00222"></a>00222         uint8_t rcode = 0;
<a name="l00223"></a>00223         uint8_t pktsize;
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         uint16_t nbytes = *nbytesptr;
<a name="l00226"></a>00226         <span class="comment">//printf(&quot;Requesting %i bytes &quot;, nbytes);</span>
<a name="l00227"></a>00227         uint8_t maxpktsize = pep-&gt;maxPktSize;
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         *nbytesptr = 0;
<a name="l00230"></a>00230         regWr(rHCTL, (pep-&gt;bmRcvToggle) ? bmRCVTOG1 : bmRCVTOG0); <span class="comment">//set toggle value</span>
<a name="l00231"></a>00231 
<a name="l00232"></a>00232         <span class="comment">// use a &#39;break&#39; to exit this loop</span>
<a name="l00233"></a>00233         <span class="keywordflow">while</span>(1) {
<a name="l00234"></a>00234                 rcode = dispatchPkt(tokIN, pep-&gt;epAddr, nak_limit); <span class="comment">//IN packet to EP-&#39;endpoint&#39;. Function takes care of NAKS.</span>
<a name="l00235"></a>00235                 <span class="keywordflow">if</span>(rcode == hrTOGERR) {
<a name="l00236"></a>00236                         <span class="comment">// yes, we flip it wrong here so that next time it is actually correct!</span>
<a name="l00237"></a>00237                         pep-&gt;bmRcvToggle = (regRd(rHRSL) &amp; bmSNDTOGRD) ? 0 : 1;
<a name="l00238"></a>00238                         regWr(rHCTL, (pep-&gt;bmRcvToggle) ? bmRCVTOG1 : bmRCVTOG0); <span class="comment">//set toggle value</span>
<a name="l00239"></a>00239                         <span class="keywordflow">continue</span>;
<a name="l00240"></a>00240                 }
<a name="l00241"></a>00241                 <span class="keywordflow">if</span>(rcode) {
<a name="l00242"></a>00242                         <span class="comment">//printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Problem! dispatchPkt %2.2x\r\n&quot;, rcode);</span>
<a name="l00243"></a>00243                         <span class="keywordflow">break</span>; <span class="comment">//should be 0, indicating ACK. Else return error code.</span>
<a name="l00244"></a>00244                 }
<a name="l00245"></a>00245                 <span class="comment">/* check for RCVDAVIRQ and generate error if not present */</span>
<a name="l00246"></a>00246                 <span class="comment">/* the only case when absence of RCVDAVIRQ makes sense is when toggle error occurred. Need to add handling for that */</span>
<a name="l00247"></a>00247                 <span class="keywordflow">if</span>((regRd(rHIRQ) &amp; bmRCVDAVIRQ) == 0) {
<a name="l00248"></a>00248                         <span class="comment">//printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Problem! NO RCVDAVIRQ!\r\n&quot;);</span>
<a name="l00249"></a>00249                         rcode = 0xf0; <span class="comment">//receive error</span>
<a name="l00250"></a>00250                         <span class="keywordflow">break</span>;
<a name="l00251"></a>00251                 }
<a name="l00252"></a>00252                 pktsize = regRd(rRCVBC); <span class="comment">//number of received bytes</span>
<a name="l00253"></a>00253                 <span class="comment">//printf(&quot;Got %i bytes \r\n&quot;, pktsize);</span>
<a name="l00254"></a>00254                 <span class="comment">// This would be OK, but...</span>
<a name="l00255"></a>00255                 <span class="comment">//assert(pktsize &lt;= nbytes);</span>
<a name="l00256"></a>00256                 <span class="keywordflow">if</span>(pktsize &gt; nbytes) {
<a name="l00257"></a>00257                         <span class="comment">// This can happen. Use of assert on Arduino locks up the Arduino.</span>
<a name="l00258"></a>00258                         <span class="comment">// So I will trim the value, and hope for the best.</span>
<a name="l00259"></a>00259                         <span class="comment">//printf(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Problem! Wanted %i bytes but got %i.\r\n&quot;, nbytes, pktsize);</span>
<a name="l00260"></a>00260                         pktsize = nbytes;
<a name="l00261"></a>00261                 }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263                 int16_t mem_left = (int16_t)nbytes - *((int16_t*)nbytesptr);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265                 <span class="keywordflow">if</span>(mem_left &lt; 0)
<a name="l00266"></a>00266                         mem_left = 0;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268                 data = bytesRd(rRCVFIFO, ((pktsize &gt; mem_left) ? mem_left : pktsize), data);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270                 regWr(rHIRQ, bmRCVDAVIRQ); <span class="comment">// Clear the IRQ &amp; free the buffer</span>
<a name="l00271"></a>00271                 *nbytesptr += pktsize; <span class="comment">// add this packet&#39;s byte count to total transfer length</span>
<a name="l00272"></a>00272 
<a name="l00273"></a>00273                 <span class="comment">/* The transfer is complete under two conditions:           */</span>
<a name="l00274"></a>00274                 <span class="comment">/* 1. The device sent a short packet (L.T. maxPacketSize)   */</span>
<a name="l00275"></a>00275                 <span class="comment">/* 2. &#39;nbytes&#39; have been transferred.                       */</span>
<a name="l00276"></a>00276                 <span class="keywordflow">if</span>((pktsize &lt; maxpktsize) || (*nbytesptr &gt;= nbytes)) <span class="comment">// have we transferred &#39;nbytes&#39; bytes?</span>
<a name="l00277"></a>00277                 {
<a name="l00278"></a>00278                         <span class="comment">// Save toggle value</span>
<a name="l00279"></a>00279                         pep-&gt;bmRcvToggle = ((regRd(rHRSL) &amp; bmRCVTOGRD)) ? 1 : 0;
<a name="l00280"></a>00280                         <span class="comment">//printf(&quot;\r\n&quot;);</span>
<a name="l00281"></a>00281                         rcode = 0;
<a name="l00282"></a>00282                         <span class="keywordflow">break</span>;
<a name="l00283"></a>00283                 } <span class="comment">// if</span>
<a name="l00284"></a>00284         } <span class="comment">//while( 1 )</span>
<a name="l00285"></a>00285         <span class="keywordflow">return</span> ( rcode);
<a name="l00286"></a>00286 }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288 <span class="comment">/* OUT transfer to arbitrary endpoint. Handles multiple packets if necessary. Transfers &#39;nbytes&#39; bytes. */</span>
<a name="l00289"></a>00289 <span class="comment">/* Handles NAK bug per Maxim Application Note 4000 for single buffer transfer   */</span>
<a name="l00290"></a>00290 
<a name="l00291"></a>00291 <span class="comment">/* rcode 0 if no errors. rcode 01-0f is relayed from HRSL                       */</span>
<a name="l00292"></a>00292 uint8_t USB::outTransfer(uint8_t addr, uint8_t ep, uint16_t nbytes, uint8_t* data) {
<a name="l00293"></a>00293         EpInfo *pep = NULL;
<a name="l00294"></a>00294         uint16_t nak_limit = 0;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296         uint8_t rcode = SetAddress(addr, ep, &amp;pep, nak_limit);
<a name="l00297"></a>00297 
<a name="l00298"></a>00298         <span class="keywordflow">if</span>(rcode)
<a name="l00299"></a>00299                 <span class="keywordflow">return</span> rcode;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301         <span class="keywordflow">return</span> OutTransfer(pep, nak_limit, nbytes, data);
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 uint8_t USB::OutTransfer(EpInfo *pep, uint16_t nak_limit, uint16_t nbytes, uint8_t *data) {
<a name="l00305"></a>00305         uint8_t rcode = hrSUCCESS, retry_count;
<a name="l00306"></a>00306         uint8_t *data_p = <a class="code" href="masstorage_8h.html#afb87d045bbf32b236fc425efe02bdc7b">data</a>; <span class="comment">//local copy of the data pointer</span>
<a name="l00307"></a>00307         uint16_t bytes_tosend, nak_count;
<a name="l00308"></a>00308         uint16_t bytes_left = nbytes;
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         uint8_t maxpktsize = pep-&gt;maxPktSize;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312         <span class="keywordflow">if</span>(maxpktsize &lt; 1 || maxpktsize &gt; 64)
<a name="l00313"></a>00313                 <span class="keywordflow">return</span> USB_ERROR_INVALID_MAX_PKT_SIZE;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> timeout = millis() + USB_XFER_TIMEOUT;
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         regWr(rHCTL, (pep-&gt;bmSndToggle) ? bmSNDTOG1 : bmSNDTOG0); <span class="comment">//set toggle value</span>
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         <span class="keywordflow">while</span>(bytes_left) {
<a name="l00320"></a>00320                 retry_count = 0;
<a name="l00321"></a>00321                 nak_count = 0;
<a name="l00322"></a>00322                 bytes_tosend = (bytes_left &gt;= maxpktsize) ? maxpktsize : bytes_left;
<a name="l00323"></a>00323                 bytesWr(rSNDFIFO, bytes_tosend, data_p); <span class="comment">//filling output FIFO</span>
<a name="l00324"></a>00324                 regWr(rSNDBC, bytes_tosend); <span class="comment">//set number of bytes</span>
<a name="l00325"></a>00325                 regWr(rHXFR, (tokOUT | pep-&gt;epAddr)); <span class="comment">//dispatch packet</span>
<a name="l00326"></a>00326                 <span class="keywordflow">while</span>(!(regRd(rHIRQ) &amp; bmHXFRDNIRQ)); <span class="comment">//wait for the completion IRQ</span>
<a name="l00327"></a>00327                 regWr(rHIRQ, bmHXFRDNIRQ); <span class="comment">//clear IRQ</span>
<a name="l00328"></a>00328                 rcode = (regRd(rHRSL) &amp; 0x0f);
<a name="l00329"></a>00329 
<a name="l00330"></a>00330                 <span class="keywordflow">while</span>(rcode &amp;&amp; (timeout &gt; millis())) {
<a name="l00331"></a>00331                         <span class="keywordflow">switch</span>(rcode) {
<a name="l00332"></a>00332                                 <span class="keywordflow">case</span> hrNAK:
<a name="l00333"></a>00333                                         nak_count++;
<a name="l00334"></a>00334                                         <span class="keywordflow">if</span>(nak_limit &amp;&amp; (nak_count == nak_limit))
<a name="l00335"></a>00335                                                 <span class="keywordflow">goto</span> breakout;
<a name="l00336"></a>00336                                         <span class="comment">//return ( rcode);</span>
<a name="l00337"></a>00337                                         <span class="keywordflow">break</span>;
<a name="l00338"></a>00338                                 <span class="keywordflow">case</span> hrTIMEOUT:
<a name="l00339"></a>00339                                         retry_count++;
<a name="l00340"></a>00340                                         <span class="keywordflow">if</span>(retry_count == USB_RETRY_LIMIT)
<a name="l00341"></a>00341                                                 <span class="keywordflow">goto</span> breakout;
<a name="l00342"></a>00342                                         <span class="comment">//return ( rcode);</span>
<a name="l00343"></a>00343                                         <span class="keywordflow">break</span>;
<a name="l00344"></a>00344                                 <span class="keywordflow">case</span> hrTOGERR:
<a name="l00345"></a>00345                                         <span class="comment">// yes, we flip it wrong here so that next time it is actually correct!</span>
<a name="l00346"></a>00346                                         pep-&gt;bmSndToggle = (regRd(rHRSL) &amp; bmSNDTOGRD) ? 0 : 1;
<a name="l00347"></a>00347                                         regWr(rHCTL, (pep-&gt;bmSndToggle) ? bmSNDTOG1 : bmSNDTOG0); <span class="comment">//set toggle value</span>
<a name="l00348"></a>00348                                         <span class="keywordflow">break</span>;
<a name="l00349"></a>00349                                 <span class="keywordflow">default</span>:
<a name="l00350"></a>00350                                         <span class="keywordflow">goto</span> breakout;
<a name="l00351"></a>00351                         }<span class="comment">//switch( rcode</span>
<a name="l00352"></a>00352 
<a name="l00353"></a>00353                         <span class="comment">/* process NAK according to Host out NAK bug */</span>
<a name="l00354"></a>00354                         regWr(rSNDBC, 0);
<a name="l00355"></a>00355                         regWr(rSNDFIFO, *data_p);
<a name="l00356"></a>00356                         regWr(rSNDBC, bytes_tosend);
<a name="l00357"></a>00357                         regWr(rHXFR, (tokOUT | pep-&gt;epAddr)); <span class="comment">//dispatch packet</span>
<a name="l00358"></a>00358                         <span class="keywordflow">while</span>(!(regRd(rHIRQ) &amp; bmHXFRDNIRQ)); <span class="comment">//wait for the completion IRQ</span>
<a name="l00359"></a>00359                         regWr(rHIRQ, bmHXFRDNIRQ); <span class="comment">//clear IRQ</span>
<a name="l00360"></a>00360                         rcode = (regRd(rHRSL) &amp; 0x0f);
<a name="l00361"></a>00361                 }<span class="comment">//while( rcode &amp;&amp; ....</span>
<a name="l00362"></a>00362                 bytes_left -= bytes_tosend;
<a name="l00363"></a>00363                 data_p += bytes_tosend;
<a name="l00364"></a>00364         }<span class="comment">//while( bytes_left...</span>
<a name="l00365"></a>00365 breakout:
<a name="l00366"></a>00366 
<a name="l00367"></a>00367         pep-&gt;bmSndToggle = (regRd(rHRSL) &amp; bmSNDTOGRD) ? 1 : 0; <span class="comment">//bmSNDTOG1 : bmSNDTOG0;  //update toggle</span>
<a name="l00368"></a>00368         <span class="keywordflow">return</span> ( rcode); <span class="comment">//should be 0 in all cases</span>
<a name="l00369"></a>00369 }
<a name="l00370"></a>00370 <span class="comment">/* dispatch USB packet. Assumes peripheral address is set and relevant buffer is loaded/empty       */</span>
<a name="l00371"></a>00371 <span class="comment">/* If NAK, tries to re-send up to nak_limit times                                                   */</span>
<a name="l00372"></a>00372 <span class="comment">/* If nak_limit == 0, do not count NAKs, exit after timeout                                         */</span>
<a name="l00373"></a>00373 <span class="comment">/* If bus timeout, re-sends up to USB_RETRY_LIMIT times                                             */</span>
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="comment">/* return codes 0x00-0x0f are HRSLT( 0x00 being success ), 0xff means timeout                       */</span>
<a name="l00376"></a>00376 uint8_t USB::dispatchPkt(uint8_t token, uint8_t ep, uint16_t nak_limit) {
<a name="l00377"></a>00377         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> timeout = millis() + USB_XFER_TIMEOUT;
<a name="l00378"></a>00378         uint8_t tmpdata;
<a name="l00379"></a>00379         uint8_t rcode = hrSUCCESS;
<a name="l00380"></a>00380         uint8_t retry_count = 0;
<a name="l00381"></a>00381         uint16_t nak_count = 0;
<a name="l00382"></a>00382 
<a name="l00383"></a>00383         <span class="keywordflow">while</span>(timeout &gt; millis()) {
<a name="l00384"></a>00384                 regWr(rHXFR, (token | ep)); <span class="comment">//launch the transfer</span>
<a name="l00385"></a>00385                 rcode = USB_ERROR_TRANSFER_TIMEOUT;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387                 <span class="keywordflow">while</span>(timeout &gt; millis()) <span class="comment">//wait for transfer completion</span>
<a name="l00388"></a>00388                 {
<a name="l00389"></a>00389                         tmpdata = regRd(rHIRQ);
<a name="l00390"></a>00390 
<a name="l00391"></a>00391                         <span class="keywordflow">if</span>(tmpdata &amp; bmHXFRDNIRQ) {
<a name="l00392"></a>00392                                 regWr(rHIRQ, bmHXFRDNIRQ); <span class="comment">//clear the interrupt</span>
<a name="l00393"></a>00393                                 rcode = 0x00;
<a name="l00394"></a>00394                                 <span class="keywordflow">break</span>;
<a name="l00395"></a>00395                         }<span class="comment">//if( tmpdata &amp; bmHXFRDNIRQ</span>
<a name="l00396"></a>00396 
<a name="l00397"></a>00397                 }<span class="comment">//while ( millis() &lt; timeout</span>
<a name="l00398"></a>00398 
<a name="l00399"></a>00399                 <span class="comment">//if (rcode != 0x00) //exit if timeout</span>
<a name="l00400"></a>00400                 <span class="comment">//        return ( rcode);</span>
<a name="l00401"></a>00401 
<a name="l00402"></a>00402                 rcode = (regRd(rHRSL) &amp; 0x0f); <span class="comment">//analyze transfer result</span>
<a name="l00403"></a>00403 
<a name="l00404"></a>00404                 <span class="keywordflow">switch</span>(rcode) {
<a name="l00405"></a>00405                         <span class="keywordflow">case</span> hrNAK:
<a name="l00406"></a>00406                                 nak_count++;
<a name="l00407"></a>00407                                 <span class="keywordflow">if</span>(nak_limit &amp;&amp; (nak_count == nak_limit))
<a name="l00408"></a>00408                                         <span class="keywordflow">return</span> (rcode);
<a name="l00409"></a>00409                                 <span class="keywordflow">break</span>;
<a name="l00410"></a>00410                         <span class="keywordflow">case</span> hrTIMEOUT:
<a name="l00411"></a>00411                                 retry_count++;
<a name="l00412"></a>00412                                 <span class="keywordflow">if</span>(retry_count == USB_RETRY_LIMIT)
<a name="l00413"></a>00413                                         <span class="keywordflow">return</span> (rcode);
<a name="l00414"></a>00414                                 <span class="keywordflow">break</span>;
<a name="l00415"></a>00415                         <span class="keywordflow">default</span>:
<a name="l00416"></a>00416                                 <span class="keywordflow">return</span> (rcode);
<a name="l00417"></a>00417                 }<span class="comment">//switch( rcode</span>
<a name="l00418"></a>00418 
<a name="l00419"></a>00419         }<span class="comment">//while( timeout &gt; millis()</span>
<a name="l00420"></a>00420         <span class="keywordflow">return</span> ( rcode);
<a name="l00421"></a>00421 }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="comment">/* USB main task. Performs enumeration/cleanup */</span>
<a name="l00424"></a>00424 <span class="keywordtype">void</span> USB::Task(<span class="keywordtype">void</span>) <span class="comment">//USB state machine</span>
<a name="l00425"></a>00425 {
<a name="l00426"></a>00426         uint8_t rcode;
<a name="l00427"></a>00427         uint8_t tmpdata;
<a name="l00428"></a>00428         <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> delay = 0;
<a name="l00429"></a>00429         <span class="comment">//USB_DEVICE_DESCRIPTOR buf;</span>
<a name="l00430"></a>00430         <span class="keywordtype">bool</span> lowspeed = <span class="keyword">false</span>;
<a name="l00431"></a>00431 
<a name="l00432"></a>00432         MAX3421E::Task();
<a name="l00433"></a>00433 
<a name="l00434"></a>00434         tmpdata = getVbusState();
<a name="l00435"></a>00435 
<a name="l00436"></a>00436         <span class="comment">/* modify USB task state if Vbus changed */</span>
<a name="l00437"></a>00437         <span class="keywordflow">switch</span>(tmpdata) {
<a name="l00438"></a>00438                 <span class="keywordflow">case</span> SE1: <span class="comment">//illegal state</span>
<a name="l00439"></a>00439                         usb_task_state = USB_DETACHED_SUBSTATE_ILLEGAL;
<a name="l00440"></a>00440                         lowspeed = <span class="keyword">false</span>;
<a name="l00441"></a>00441                         <span class="keywordflow">break</span>;
<a name="l00442"></a>00442                 <span class="keywordflow">case</span> SE0: <span class="comment">//disconnected</span>
<a name="l00443"></a>00443                         <span class="keywordflow">if</span>((usb_task_state &amp; USB_STATE_MASK) != USB_STATE_DETACHED)
<a name="l00444"></a>00444                                 usb_task_state = USB_DETACHED_SUBSTATE_INITIALIZE;
<a name="l00445"></a>00445                         lowspeed = <span class="keyword">false</span>;
<a name="l00446"></a>00446                         <span class="keywordflow">break</span>;
<a name="l00447"></a>00447                 <span class="keywordflow">case</span> LSHOST:
<a name="l00448"></a>00448 
<a name="l00449"></a>00449                         lowspeed = <span class="keyword">true</span>;
<a name="l00450"></a>00450                         <span class="comment">//intentional fallthrough</span>
<a name="l00451"></a>00451                 <span class="keywordflow">case</span> FSHOST: <span class="comment">//attached</span>
<a name="l00452"></a>00452                         <span class="keywordflow">if</span>((usb_task_state &amp; USB_STATE_MASK) == USB_STATE_DETACHED) {
<a name="l00453"></a>00453                                 delay = millis() + USB_SETTLE_DELAY;
<a name="l00454"></a>00454                                 usb_task_state = USB_ATTACHED_SUBSTATE_SETTLE;
<a name="l00455"></a>00455                         }
<a name="l00456"></a>00456                         <span class="keywordflow">break</span>;
<a name="l00457"></a>00457         }<span class="comment">// switch( tmpdata</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459         <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; USB_NUMDEVICES; i++)
<a name="l00460"></a>00460                 <span class="keywordflow">if</span>(devConfig[i])
<a name="l00461"></a>00461                         rcode = devConfig[i]-&gt;Poll();
<a name="l00462"></a>00462 
<a name="l00463"></a>00463         <span class="keywordflow">switch</span>(usb_task_state) {
<a name="l00464"></a>00464                 <span class="keywordflow">case</span> USB_DETACHED_SUBSTATE_INITIALIZE:
<a name="l00465"></a>00465                         init();
<a name="l00466"></a>00466 
<a name="l00467"></a>00467                         <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; USB_NUMDEVICES; i++)
<a name="l00468"></a>00468                                 <span class="keywordflow">if</span>(devConfig[i])
<a name="l00469"></a>00469                                         rcode = devConfig[i]-&gt;Release();
<a name="l00470"></a>00470 
<a name="l00471"></a>00471                         usb_task_state = USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE;
<a name="l00472"></a>00472                         <span class="keywordflow">break</span>;
<a name="l00473"></a>00473                 <span class="keywordflow">case</span> USB_DETACHED_SUBSTATE_WAIT_FOR_DEVICE: <span class="comment">//just sit here</span>
<a name="l00474"></a>00474                         <span class="keywordflow">break</span>;
<a name="l00475"></a>00475                 <span class="keywordflow">case</span> USB_DETACHED_SUBSTATE_ILLEGAL: <span class="comment">//just sit here</span>
<a name="l00476"></a>00476                         <span class="keywordflow">break</span>;
<a name="l00477"></a>00477                 <span class="keywordflow">case</span> USB_ATTACHED_SUBSTATE_SETTLE: <span class="comment">//settle time for just attached device</span>
<a name="l00478"></a>00478                         <span class="keywordflow">if</span>(delay &lt; millis())
<a name="l00479"></a>00479                                 usb_task_state = USB_ATTACHED_SUBSTATE_RESET_DEVICE;
<a name="l00480"></a>00480                         <span class="keywordflow">else</span> <span class="keywordflow">break</span>; <span class="comment">// don&#39;t fall through</span>
<a name="l00481"></a>00481                 <span class="keywordflow">case</span> USB_ATTACHED_SUBSTATE_RESET_DEVICE:
<a name="l00482"></a>00482                         regWr(rHCTL, bmBUSRST); <span class="comment">//issue bus reset</span>
<a name="l00483"></a>00483                         usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE;
<a name="l00484"></a>00484                         <span class="keywordflow">break</span>;
<a name="l00485"></a>00485                 <span class="keywordflow">case</span> USB_ATTACHED_SUBSTATE_WAIT_RESET_COMPLETE:
<a name="l00486"></a>00486                         <span class="keywordflow">if</span>((regRd(rHCTL) &amp; bmBUSRST) == 0) {
<a name="l00487"></a>00487                                 tmpdata = regRd(rMODE) | bmSOFKAENAB; <span class="comment">//start SOF generation</span>
<a name="l00488"></a>00488                                 regWr(rMODE, tmpdata);
<a name="l00489"></a>00489                                 usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_SOF;
<a name="l00490"></a>00490                                 <span class="comment">//delay = millis() + 20; //20ms wait after reset per USB spec</span>
<a name="l00491"></a>00491                         }
<a name="l00492"></a>00492                         <span class="keywordflow">break</span>;
<a name="l00493"></a>00493                 <span class="keywordflow">case</span> USB_ATTACHED_SUBSTATE_WAIT_SOF: <span class="comment">//todo: change check order</span>
<a name="l00494"></a>00494                         <span class="keywordflow">if</span>(regRd(rHIRQ) &amp; bmFRAMEIRQ) {
<a name="l00495"></a>00495                                 <span class="comment">//when first SOF received _and_ 20ms has passed we can continue</span>
<a name="l00496"></a>00496                                 <span class="comment">/*</span>
<a name="l00497"></a>00497 <span class="comment">                                if (delay &lt; millis()) //20ms passed</span>
<a name="l00498"></a>00498 <span class="comment">                                        usb_task_state = USB_STATE_CONFIGURING;</span>
<a name="l00499"></a>00499 <span class="comment">                                 */</span>
<a name="l00500"></a>00500                                 usb_task_state = USB_ATTACHED_SUBSTATE_WAIT_RESET;
<a name="l00501"></a>00501                                 delay = millis() + 20;
<a name="l00502"></a>00502                         }
<a name="l00503"></a>00503                         <span class="keywordflow">break</span>;
<a name="l00504"></a>00504                 <span class="keywordflow">case</span> USB_ATTACHED_SUBSTATE_WAIT_RESET:
<a name="l00505"></a>00505                         <span class="keywordflow">if</span>(delay &lt; millis()) usb_task_state = USB_STATE_CONFIGURING;
<a name="l00506"></a>00506                         <span class="keywordflow">else</span> <span class="keywordflow">break</span>; <span class="comment">// don&#39;t fall through</span>
<a name="l00507"></a>00507                 <span class="keywordflow">case</span> USB_STATE_CONFIGURING:
<a name="l00508"></a>00508 
<a name="l00509"></a>00509                         <span class="comment">//Serial.print(&quot;\r\nConf.LS: &quot;);</span>
<a name="l00510"></a>00510                         <span class="comment">//Serial.println(lowspeed, HEX);</span>
<a name="l00511"></a>00511 
<a name="l00512"></a>00512                         rcode = Configuring(0, 0, lowspeed);
<a name="l00513"></a>00513 
<a name="l00514"></a>00514                         <span class="keywordflow">if</span>(rcode) {
<a name="l00515"></a>00515                                 <span class="keywordflow">if</span>(rcode != USB_DEV_CONFIG_ERROR_DEVICE_INIT_INCOMPLETE) {
<a name="l00516"></a>00516                                         usb_error = rcode;
<a name="l00517"></a>00517                                         usb_task_state = USB_STATE_ERROR;
<a name="l00518"></a>00518                                 }
<a name="l00519"></a>00519                         } <span class="keywordflow">else</span>
<a name="l00520"></a>00520                                 usb_task_state = USB_STATE_RUNNING;
<a name="l00521"></a>00521                         <span class="keywordflow">break</span>;
<a name="l00522"></a>00522                 <span class="keywordflow">case</span> USB_STATE_RUNNING:
<a name="l00523"></a>00523                         <span class="keywordflow">break</span>;
<a name="l00524"></a>00524                 <span class="keywordflow">case</span> USB_STATE_ERROR:
<a name="l00525"></a>00525                         <span class="comment">//MAX3421E::Init();</span>
<a name="l00526"></a>00526                         <span class="keywordflow">break</span>;
<a name="l00527"></a>00527         } <span class="comment">// switch( usb_task_state )</span>
<a name="l00528"></a>00528 }
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 uint8_t USB::DefaultAddressing(uint8_t parent, uint8_t port, <span class="keywordtype">bool</span> lowspeed) {
<a name="l00531"></a>00531         <span class="comment">//uint8_t               buf[12];</span>
<a name="l00532"></a>00532         uint8_t rcode;
<a name="l00533"></a>00533         UsbDevice *p0 = NULL, *p = NULL;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535         <span class="comment">// Get pointer to pseudo device with address 0 assigned</span>
<a name="l00536"></a>00536         p0 = addrPool.GetUsbDevicePtr(0);
<a name="l00537"></a>00537 
<a name="l00538"></a>00538         <span class="keywordflow">if</span>(!p0)
<a name="l00539"></a>00539                 <span class="keywordflow">return</span> USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
<a name="l00540"></a>00540 
<a name="l00541"></a>00541         <span class="keywordflow">if</span>(!p0-&gt;epinfo)
<a name="l00542"></a>00542                 <span class="keywordflow">return</span> USB_ERROR_EPINFO_IS_NULL;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544         p0-&gt;lowspeed = (lowspeed) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l00545"></a>00545 
<a name="l00546"></a>00546         <span class="comment">// Allocate new address according to device class</span>
<a name="l00547"></a>00547         uint8_t bAddress = addrPool.AllocAddress(parent, <span class="keyword">false</span>, port);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549         <span class="keywordflow">if</span>(!bAddress)
<a name="l00550"></a>00550                 <span class="keywordflow">return</span> USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552         p = addrPool.GetUsbDevicePtr(bAddress);
<a name="l00553"></a>00553 
<a name="l00554"></a>00554         <span class="keywordflow">if</span>(!p)
<a name="l00555"></a>00555                 <span class="keywordflow">return</span> USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557         p-&gt;lowspeed = lowspeed;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559         <span class="comment">// Assign new address to the device</span>
<a name="l00560"></a>00560         rcode = setAddr(0, 0, bAddress);
<a name="l00561"></a>00561 
<a name="l00562"></a>00562         <span class="keywordflow">if</span>(rcode) {
<a name="l00563"></a>00563                 addrPool.FreeAddress(bAddress);
<a name="l00564"></a>00564                 bAddress = 0;
<a name="l00565"></a>00565                 <span class="keywordflow">return</span> rcode;
<a name="l00566"></a>00566         }
<a name="l00567"></a>00567         <span class="keywordflow">return</span> 0;
<a name="l00568"></a>00568 };
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 uint8_t USB::AttemptConfig(uint8_t driver, uint8_t parent, uint8_t port, <span class="keywordtype">bool</span> lowspeed) {
<a name="l00571"></a>00571         <span class="comment">//printf(&quot;AttemptConfig: parent = %i, port = %i\r\n&quot;, parent, port);</span>
<a name="l00572"></a>00572         uint8_t retries = 0;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 again:
<a name="l00575"></a>00575         uint8_t rcode = devConfig[driver]-&gt;ConfigureDevice(parent, port, lowspeed);
<a name="l00576"></a>00576         <span class="keywordflow">if</span>(rcode == USB_ERROR_CONFIG_REQUIRES_ADDITIONAL_RESET) {
<a name="l00577"></a>00577                 <span class="keywordflow">if</span>(parent == 0) {
<a name="l00578"></a>00578                         <span class="comment">// Send a bus reset on the root interface.</span>
<a name="l00579"></a>00579                         regWr(rHCTL, bmBUSRST); <span class="comment">//issue bus reset</span>
<a name="l00580"></a>00580                         delay(102); <span class="comment">// delay 102ms, compensate for clock inaccuracy.</span>
<a name="l00581"></a>00581                 } <span class="keywordflow">else</span> {
<a name="l00582"></a>00582                         <span class="comment">// reset parent port</span>
<a name="l00583"></a>00583                         devConfig[parent]-&gt;ResetHubPort(port);
<a name="l00584"></a>00584                 }
<a name="l00585"></a>00585         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rcode == hrJERR &amp;&amp; retries &lt; 3) { <span class="comment">// Some devices returns this when plugged in - trying to initialize the device again usually works</span>
<a name="l00586"></a>00586                 delay(100);
<a name="l00587"></a>00587                 retries++;
<a name="l00588"></a>00588                 <span class="keywordflow">goto</span> again;
<a name="l00589"></a>00589         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(rcode)
<a name="l00590"></a>00590                 <span class="keywordflow">return</span> rcode;
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         rcode = devConfig[driver]-&gt;Init(parent, port, lowspeed);
<a name="l00593"></a>00593         <span class="keywordflow">if</span>(rcode == hrJERR &amp;&amp; retries &lt; 3) { <span class="comment">// Some devices returns this when plugged in - trying to initialize the device again usually works</span>
<a name="l00594"></a>00594                 delay(100);
<a name="l00595"></a>00595                 retries++;
<a name="l00596"></a>00596                 <span class="keywordflow">goto</span> again;
<a name="l00597"></a>00597         }
<a name="l00598"></a>00598         <span class="keywordflow">if</span>(rcode) {
<a name="l00599"></a>00599                 <span class="comment">// Issue a bus reset, because the device may be in a limbo state</span>
<a name="l00600"></a>00600                 <span class="keywordflow">if</span>(parent == 0) {
<a name="l00601"></a>00601                         <span class="comment">// Send a bus reset on the root interface.</span>
<a name="l00602"></a>00602                         regWr(rHCTL, bmBUSRST); <span class="comment">//issue bus reset</span>
<a name="l00603"></a>00603                         delay(102); <span class="comment">// delay 102ms, compensate for clock inaccuracy.</span>
<a name="l00604"></a>00604                 } <span class="keywordflow">else</span> {
<a name="l00605"></a>00605                         <span class="comment">// reset parent port</span>
<a name="l00606"></a>00606                         devConfig[parent]-&gt;ResetHubPort(port);
<a name="l00607"></a>00607                 }
<a name="l00608"></a>00608         }
<a name="l00609"></a>00609         <span class="keywordflow">return</span> rcode;
<a name="l00610"></a>00610 }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 <span class="comment">/*</span>
<a name="l00613"></a>00613 <span class="comment"> * This is broken. We need to enumerate differently.</span>
<a name="l00614"></a>00614 <span class="comment"> * It causes major problems with several devices if detected in an unexpected order.</span>
<a name="l00615"></a>00615 <span class="comment"> *</span>
<a name="l00616"></a>00616 <span class="comment"> *</span>
<a name="l00617"></a>00617 <span class="comment"> * Oleg - I wouldn&#39;t do anything before the newly connected device is considered sane.</span>
<a name="l00618"></a>00618 <span class="comment"> * i.e.(delays are not indicated for brevity):</span>
<a name="l00619"></a>00619 <span class="comment"> * 1. reset</span>
<a name="l00620"></a>00620 <span class="comment"> * 2. GetDevDescr();</span>
<a name="l00621"></a>00621 <span class="comment"> * 3a. If ACK, continue with allocating address, addressing, etc.</span>
<a name="l00622"></a>00622 <span class="comment"> * 3b. Else reset again, count resets, stop at some number (5?).</span>
<a name="l00623"></a>00623 <span class="comment"> * 4. When max.number of resets is reached, toggle power/fail</span>
<a name="l00624"></a>00624 <span class="comment"> * If desired, this could be modified by performing two resets with GetDevDescr() in the middle - however, from my experience, if a device answers to GDD()</span>
<a name="l00625"></a>00625 <span class="comment"> * it doesn&#39;t need to be reset again</span>
<a name="l00626"></a>00626 <span class="comment"> * New steps proposal:</span>
<a name="l00627"></a>00627 <span class="comment"> * 1: get address pool instance. exit on fail</span>
<a name="l00628"></a>00628 <span class="comment"> * 2: pUsb-&gt;getDevDescr(0, 0, constBufSize, (uint8_t*)buf). exit on fail.</span>
<a name="l00629"></a>00629 <span class="comment"> * 3: bus reset, 100ms delay</span>
<a name="l00630"></a>00630 <span class="comment"> * 4: set address</span>
<a name="l00631"></a>00631 <span class="comment"> * 5: pUsb-&gt;setEpInfoEntry(bAddress, 1, epInfo), exit on fail</span>
<a name="l00632"></a>00632 <span class="comment"> * 6: while (configurations) {</span>
<a name="l00633"></a>00633 <span class="comment"> *              for(each configuration) {</span>
<a name="l00634"></a>00634 <span class="comment"> *                      for (each driver) {</span>
<a name="l00635"></a>00635 <span class="comment"> *                              6a: Ask device if it likes configuration. Returns 0 on OK.</span>
<a name="l00636"></a>00636 <span class="comment"> *                                      If successful, the driver configured device.</span>
<a name="l00637"></a>00637 <span class="comment"> *                                      The driver now owns the endpoints, and takes over managing them.</span>
<a name="l00638"></a>00638 <span class="comment"> *                                      The following will need codes:</span>
<a name="l00639"></a>00639 <span class="comment"> *                                          Everything went well, instance consumed, exit with success.</span>
<a name="l00640"></a>00640 <span class="comment"> *                                          Instance already in use, ignore it, try next driver.</span>
<a name="l00641"></a>00641 <span class="comment"> *                                          Not a supported device, ignore it, try next driver.</span>
<a name="l00642"></a>00642 <span class="comment"> *                                          Not a supported configuration for this device, ignore it, try next driver.</span>
<a name="l00643"></a>00643 <span class="comment"> *                                          Could not configure device, fatal, exit with fail.</span>
<a name="l00644"></a>00644 <span class="comment"> *                      }</span>
<a name="l00645"></a>00645 <span class="comment"> *              }</span>
<a name="l00646"></a>00646 <span class="comment"> *    }</span>
<a name="l00647"></a>00647 <span class="comment"> * 7: for(each driver) {</span>
<a name="l00648"></a>00648 <span class="comment"> *      7a: Ask device if it knows this VID/PID. Acts exactly like 6a, but using VID/PID</span>
<a name="l00649"></a>00649 <span class="comment"> * 8: if we get here, no driver likes the device plugged in, so exit failure.</span>
<a name="l00650"></a>00650 <span class="comment"> *</span>
<a name="l00651"></a>00651 <span class="comment"> */</span>
<a name="l00652"></a>00652 uint8_t USB::Configuring(uint8_t parent, uint8_t port, <span class="keywordtype">bool</span> lowspeed) {
<a name="l00653"></a>00653         <span class="comment">//uint8_t bAddress = 0;</span>
<a name="l00654"></a>00654         <span class="comment">//printf(&quot;Configuring: parent = %i, port = %i\r\n&quot;, parent, port);</span>
<a name="l00655"></a>00655         uint8_t devConfigIndex;
<a name="l00656"></a>00656         uint8_t rcode = 0;
<a name="l00657"></a>00657         uint8_t buf[<span class="keyword">sizeof</span> (USB_DEVICE_DESCRIPTOR)];
<a name="l00658"></a>00658         USB_DEVICE_DESCRIPTOR *udd = <span class="keyword">reinterpret_cast&lt;</span>USB_DEVICE_DESCRIPTOR *<span class="keyword">&gt;</span>(buf);
<a name="l00659"></a>00659         UsbDevice *p = NULL;
<a name="l00660"></a>00660         EpInfo *oldep_ptr = NULL;
<a name="l00661"></a>00661         EpInfo epInfo;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663         epInfo.epAddr = 0;
<a name="l00664"></a>00664         epInfo.maxPktSize = 8;
<a name="l00665"></a>00665         epInfo.epAttribs = 0;
<a name="l00666"></a>00666         epInfo.bmNakPower = USB_NAK_MAX_POWER;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668         <span class="comment">//delay(2000);</span>
<a name="l00669"></a>00669         AddressPool &amp;addrPool = GetAddressPool();
<a name="l00670"></a>00670         <span class="comment">// Get pointer to pseudo device with address 0 assigned</span>
<a name="l00671"></a>00671         p = addrPool.GetUsbDevicePtr(0);
<a name="l00672"></a>00672         <span class="keywordflow">if</span>(!p) {
<a name="l00673"></a>00673                 <span class="comment">//printf(&quot;Configuring error: USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL\r\n&quot;);</span>
<a name="l00674"></a>00674                 <span class="keywordflow">return</span> USB_ERROR_ADDRESS_NOT_FOUND_IN_POOL;
<a name="l00675"></a>00675         }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         <span class="comment">// Save old pointer to EP_RECORD of address 0</span>
<a name="l00678"></a>00678         oldep_ptr = p-&gt;epinfo;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680         <span class="comment">// Temporary assign new pointer to epInfo to p-&gt;epinfo in order to</span>
<a name="l00681"></a>00681         <span class="comment">// avoid toggle inconsistence</span>
<a name="l00682"></a>00682 
<a name="l00683"></a>00683         p-&gt;epinfo = &amp;epInfo;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685         p-&gt;lowspeed = lowspeed;
<a name="l00686"></a>00686         <span class="comment">// Get device descriptor</span>
<a name="l00687"></a>00687         rcode = getDevDescr(0, 0, <span class="keyword">sizeof</span> (USB_DEVICE_DESCRIPTOR), (uint8_t*)buf);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689         <span class="comment">// Restore p-&gt;epinfo</span>
<a name="l00690"></a>00690         p-&gt;epinfo = oldep_ptr;
<a name="l00691"></a>00691 
<a name="l00692"></a>00692         <span class="keywordflow">if</span>(rcode) {
<a name="l00693"></a>00693                 <span class="comment">//printf(&quot;Configuring error: Can&#39;t get USB_DEVICE_DESCRIPTOR\r\n&quot;);</span>
<a name="l00694"></a>00694                 <span class="keywordflow">return</span> rcode;
<a name="l00695"></a>00695         }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697         <span class="comment">// to-do?</span>
<a name="l00698"></a>00698         <span class="comment">// Allocate new address according to device class</span>
<a name="l00699"></a>00699         <span class="comment">//bAddress = addrPool.AllocAddress(parent, false, port);</span>
<a name="l00700"></a>00700 
<a name="l00701"></a>00701         <span class="comment">//if (!bAddress)</span>
<a name="l00702"></a>00702         <span class="comment">//        return USB_ERROR_OUT_OF_ADDRESS_SPACE_IN_POOL;</span>
<a name="l00703"></a>00703         uint16_t vid = udd-&gt;idVendor;
<a name="l00704"></a>00704         uint16_t pid = udd-&gt;idProduct;
<a name="l00705"></a>00705         uint8_t klass = udd-&gt;bDeviceClass;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707         <span class="comment">// Attempt to configure if VID/PID or device class matches with a driver</span>
<a name="l00708"></a>00708         <span class="keywordflow">for</span>(devConfigIndex = 0; devConfigIndex &lt; USB_NUMDEVICES; devConfigIndex++) {
<a name="l00709"></a>00709                 <span class="keywordflow">if</span>(!devConfig[devConfigIndex]) <span class="keywordflow">continue</span>; <span class="comment">// no driver</span>
<a name="l00710"></a>00710                 <span class="keywordflow">if</span>(devConfig[devConfigIndex]-&gt;GetAddress()) <span class="keywordflow">continue</span>; <span class="comment">// consumed</span>
<a name="l00711"></a>00711                 <span class="keywordflow">if</span>(devConfig[devConfigIndex]-&gt;VIDPIDOK(vid, pid) || devConfig[devConfigIndex]-&gt;DEVCLASSOK(klass)) {
<a name="l00712"></a>00712                         rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
<a name="l00713"></a>00713                         <span class="keywordflow">if</span>(rcode != USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED)
<a name="l00714"></a>00714                                 <span class="keywordflow">break</span>;
<a name="l00715"></a>00715                 }
<a name="l00716"></a>00716         }
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         <span class="keywordflow">if</span>(devConfigIndex &lt; USB_NUMDEVICES) {
<a name="l00719"></a>00719                 <span class="keywordflow">return</span> rcode;
<a name="l00720"></a>00720         }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         <span class="comment">// blindly attempt to configure</span>
<a name="l00724"></a>00724         <span class="keywordflow">for</span>(devConfigIndex = 0; devConfigIndex &lt; USB_NUMDEVICES; devConfigIndex++) {
<a name="l00725"></a>00725                 <span class="keywordflow">if</span>(!devConfig[devConfigIndex]) <span class="keywordflow">continue</span>;
<a name="l00726"></a>00726                 <span class="keywordflow">if</span>(devConfig[devConfigIndex]-&gt;GetAddress()) <span class="keywordflow">continue</span>; <span class="comment">// consumed</span>
<a name="l00727"></a>00727                 <span class="keywordflow">if</span>(devConfig[devConfigIndex]-&gt;VIDPIDOK(vid, pid) || devConfig[devConfigIndex]-&gt;DEVCLASSOK(klass)) <span class="keywordflow">continue</span>; <span class="comment">// If this is true it means it must have returned USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED above</span>
<a name="l00728"></a>00728                 rcode = AttemptConfig(devConfigIndex, parent, port, lowspeed);
<a name="l00729"></a>00729 
<a name="l00730"></a>00730                 <span class="comment">//printf(&quot;ERROR ENUMERATING %2.2x\r\n&quot;, rcode);</span>
<a name="l00731"></a>00731                 <span class="keywordflow">if</span>(!(rcode == USB_DEV_CONFIG_ERROR_DEVICE_NOT_SUPPORTED || rcode == USB_ERROR_CLASS_INSTANCE_ALREADY_IN_USE)) {
<a name="l00732"></a>00732                         <span class="comment">// in case of an error dev_index should be reset to 0</span>
<a name="l00733"></a>00733                         <span class="comment">//              in order to start from the very beginning the</span>
<a name="l00734"></a>00734                         <span class="comment">//              next time the program gets here</span>
<a name="l00735"></a>00735                         <span class="comment">//if (rcode != USB_DEV_CONFIG_ERROR_DEVICE_INIT_INCOMPLETE)</span>
<a name="l00736"></a>00736                         <span class="comment">//        devConfigIndex = 0;</span>
<a name="l00737"></a>00737                         <span class="keywordflow">return</span> rcode;
<a name="l00738"></a>00738                 }
<a name="l00739"></a>00739         }
<a name="l00740"></a>00740         <span class="comment">// if we get here that means that the device class is not supported by any of registered classes</span>
<a name="l00741"></a>00741         rcode = DefaultAddressing(parent, port, lowspeed);
<a name="l00742"></a>00742 
<a name="l00743"></a>00743         <span class="keywordflow">return</span> rcode;
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 uint8_t USB::ReleaseDevice(uint8_t addr) {
<a name="l00747"></a>00747         <span class="keywordflow">if</span>(!addr)
<a name="l00748"></a>00748                 <span class="keywordflow">return</span> 0;
<a name="l00749"></a>00749 
<a name="l00750"></a>00750         <span class="keywordflow">for</span>(uint8_t i = 0; i &lt; USB_NUMDEVICES; i++) {
<a name="l00751"></a>00751                 <span class="keywordflow">if</span>(!devConfig[i]) <span class="keywordflow">continue</span>;
<a name="l00752"></a>00752                 <span class="keywordflow">if</span>(devConfig[i]-&gt;GetAddress() == addr)
<a name="l00753"></a>00753                         <span class="keywordflow">return</span> devConfig[i]-&gt;Release();
<a name="l00754"></a>00754         }
<a name="l00755"></a>00755         <span class="keywordflow">return</span> 0;
<a name="l00756"></a>00756 }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="preprocessor">#if 1 //!defined(USB_METHODS_INLINE)</span>
<a name="l00759"></a>00759 <span class="preprocessor"></span><span class="comment">//get device descriptor</span>
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 uint8_t USB::getDevDescr(uint8_t addr, uint8_t ep, uint16_t nbytes, uint8_t* dataptr) {
<a name="l00762"></a>00762         <span class="keywordflow">return</span> ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, 0x00, USB_DESCRIPTOR_DEVICE, 0x0000, nbytes, nbytes, dataptr, NULL));
<a name="l00763"></a>00763 }
<a name="l00764"></a>00764 <span class="comment">//get configuration descriptor</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 uint8_t USB::getConfDescr(uint8_t addr, uint8_t ep, uint16_t nbytes, uint8_t conf, uint8_t* dataptr) {
<a name="l00767"></a>00767         <span class="keywordflow">return</span> ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, conf, USB_DESCRIPTOR_CONFIGURATION, 0x0000, nbytes, nbytes, dataptr, NULL));
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 <span class="comment">/* Requests Configuration Descriptor. Sends two Get Conf Descr requests. The first one gets the total length of all descriptors, then the second one requests this</span>
<a name="l00771"></a>00771 <span class="comment"> total length. The length of the first request can be shorter ( 4 bytes ), however, there are devices which won&#39;t work unless this length is set to 9 */</span>
<a name="l00772"></a>00772 uint8_t USB::getConfDescr(uint8_t addr, uint8_t ep, uint8_t conf, USBReadParser *p) {
<a name="l00773"></a>00773         <span class="keyword">const</span> uint8_t bufSize = 64;
<a name="l00774"></a>00774         uint8_t buf[bufSize];
<a name="l00775"></a>00775         USB_CONFIGURATION_DESCRIPTOR *ucd = <span class="keyword">reinterpret_cast&lt;</span>USB_CONFIGURATION_DESCRIPTOR *<span class="keyword">&gt;</span>(buf);
<a name="l00776"></a>00776 
<a name="l00777"></a>00777         uint8_t ret = getConfDescr(addr, ep, 9, conf, buf);
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         <span class="keywordflow">if</span>(ret)
<a name="l00780"></a>00780                 <span class="keywordflow">return</span> ret;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782         uint16_t total = ucd-&gt;wTotalLength;
<a name="l00783"></a>00783 
<a name="l00784"></a>00784         <span class="comment">//USBTRACE2(&quot;\r\ntotal conf.size:&quot;, total);</span>
<a name="l00785"></a>00785 
<a name="l00786"></a>00786         <span class="keywordflow">return</span> ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, conf, USB_DESCRIPTOR_CONFIGURATION, 0x0000, total, bufSize, buf, p));
<a name="l00787"></a>00787 }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 <span class="comment">//get string descriptor</span>
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 uint8_t USB::getStrDescr(uint8_t addr, uint8_t ep, uint16_t ns, uint8_t index, uint16_t langid, uint8_t* dataptr) {
<a name="l00792"></a>00792         <span class="keywordflow">return</span> ( ctrlReq(addr, ep, bmREQ_GET_DESCR, USB_REQUEST_GET_DESCRIPTOR, index, USB_DESCRIPTOR_STRING, langid, ns, ns, dataptr, NULL));
<a name="l00793"></a>00793 }
<a name="l00794"></a>00794 <span class="comment">//set address</span>
<a name="l00795"></a>00795 
<a name="l00796"></a>00796 uint8_t USB::setAddr(uint8_t oldaddr, uint8_t ep, uint8_t newaddr) {
<a name="l00797"></a>00797         uint8_t rcode = ctrlReq(oldaddr, ep, bmREQ_SET, USB_REQUEST_SET_ADDRESS, newaddr, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL);
<a name="l00798"></a>00798         <span class="comment">//delay(2); //per USB 2.0 sect.9.2.6.3</span>
<a name="l00799"></a>00799         delay(300); <span class="comment">// Older spec says you should wait at least 200ms</span>
<a name="l00800"></a>00800         <span class="keywordflow">return</span> rcode;
<a name="l00801"></a>00801         <span class="comment">//return ( ctrlReq(oldaddr, ep, bmREQ_SET, USB_REQUEST_SET_ADDRESS, newaddr, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL));</span>
<a name="l00802"></a>00802 }
<a name="l00803"></a>00803 <span class="comment">//set configuration</span>
<a name="l00804"></a>00804 
<a name="l00805"></a>00805 uint8_t USB::setConf(uint8_t addr, uint8_t ep, uint8_t conf_value) {
<a name="l00806"></a>00806         <span class="keywordflow">return</span> ( ctrlReq(addr, ep, bmREQ_SET, USB_REQUEST_SET_CONFIGURATION, conf_value, 0x00, 0x0000, 0x0000, 0x0000, NULL, NULL));
<a name="l00807"></a>00807 }
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 <span class="preprocessor">#endif // defined(USB_METHODS_INLINE)</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 11 2014 11:28:29 for ADS1298_BLE_Sensor_Polling_Driven by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
