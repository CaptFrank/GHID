.TH "GHID_EEPROM" 3 "Sun Mar 30 2014" "Version version 2.0" "GHID Framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
GHID_EEPROM \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <GHID_EEPROM\&.h>\fP
.PP
Inherits \fBEEPROMClass\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBGHID_EEPROM\fP ()"
.br
.RI "\fIPublic context\&. \fP"
.ti -1c
.RI "void \fBwrite_data\fP (int eeprom_ptr, byte *\fBdata\fP, byte length)"
.br
.RI "\fIWrite data is not full\&. \fP"
.ti -1c
.RI "void \fBread_data\fP (\fBbuffer_struct_t\fP *buffer, int eeprom_ptr)"
.br
.RI "\fIRead data\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
This class is an override of the Arduino EEPROM class, which handles, the eeprom reading and writing on the internal Arduino eeprom\&.
.PP
\fBSee also:\fP
.RS 4
EEPROMClass\&.h 
.RE
.PP

.PP
Definition at line 35 of file GHID_EEPROM\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBGHID_EEPROM::GHID_EEPROM\fP ()"
.PP
Public context\&. The default constructor\&.
.PP
The default constructor\&. In the default constructor, we check the filesystem integrity, and the remaining space\&. We check the file intergrity
.PP
We check if the file is full 
.PP
Definition at line 11 of file GHID_EEPROM\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "void \fBGHID_EEPROM::read_data\fP (\fBbuffer_struct_t\fP *buffer, inteeprom_ptr)"
.PP
Read data\&. The following is a method that also follows the same path as the given \fBread()\fP function in the \fBEEPROMClass\fP API, but instead of reading a byte at a time, we read a certain number of bytes into a buffer\&.
.PP
\fBParameters:\fP
.RS 4
\fIbuffer_struct_t*\fP - a pointer to a buffer structure 
.br
\fIeeprom_ptr\fP - the start address to read 
.RE
.PP
Iterate the bytes
.PP
Assign the data to the buffe struct 
.PP
Definition at line 43 of file GHID_EEPROM\&.cpp\&.
.SS "void \fBGHID_EEPROM::write_data\fP (inteeprom_ptr, byte *data, bytelength)"
.PP
Write data is not full\&. The extended class has 2 methods that are used\&.
.IP "\(bu" 2
read(eeprom_address)
.IP "  \(bu" 4
The eeprom address parameter is the address of the eeprom that we wish to read\&.
.PP

.PP
.PP
.IP "\(bu" 2
write(eeprom_address, data)
.IP "  \(bu" 4
The eeprom address parameter that we wish to write to\&.
.IP "  \(bu" 4
The data is the data that we wish to write to the eeprom\&.
.PP

.PP
.PP
Note: these 2 methods override the full flag\&. The following method is essentially the same method, provided by the \fBEEPROMClass\fP API, but instead it uses a byte* and a length\&. This method is advantageous, as it throws less data on the stack\&.
.PP
\fBParameters:\fP
.RS 4
\fIeeprom_ptr\fP - byte data address at which we will write the data to 
.br
\fIdata\fP - byte* data pointer 
.br
\fIlength\fP - byte length of data to write\&. 
.RE
.PP
Check if full
.PP
Write data
.PP
We update the space 
.PP
Definition at line 28 of file GHID_EEPROM\&.cpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for GHID Framework from the source code\&.
