.TH "BTD" 3 "Sun Mar 30 2014" "Version version 2.0" "GHID Framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BTD \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <BTD\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBTD\fP (USB *p)"
.br
.ti -1c
.RI "void \fBdisconnect\fP ()"
.br
.ti -1c
.RI "int8_t \fBregisterServiceClass\fP (\fBBluetoothService\fP *pService)"
.br
.ti -1c
.RI "void \fBpairWithWiimote\fP ()"
.br
.ti -1c
.RI "void \fBpairWithHID\fP ()"
.br
.ti -1c
.RI "uint8_t \fBreadPollInterval\fP ()"
.br
.in -1c
.PP
.RI "\fBUSBDeviceConfig implementation\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "virtual uint8_t \fBConfigureDevice\fP (uint8_t parent, uint8_t port, bool lowspeed)"
.br
.ti -1c
.RI "virtual uint8_t \fBInit\fP (uint8_t parent, uint8_t port, bool lowspeed)"
.br
.ti -1c
.RI "virtual uint8_t \fBRelease\fP ()"
.br
.ti -1c
.RI "virtual uint8_t \fBPoll\fP ()"
.br
.ti -1c
.RI "virtual uint8_t \fBGetAddress\fP ()"
.br
.ti -1c
.RI "virtual bool \fBisReady\fP ()"
.br
.ti -1c
.RI "virtual boolean \fBDEVCLASSOK\fP (uint8_t klass)"
.br
.ti -1c
.RI "virtual boolean \fBVIDPIDOK\fP (uint16_t vid, uint16_t pid)"
.br
.in -1c
.in -1c
.PP
.RI "\fBUsbConfigXtracter implementation\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "virtual void \fBEndpointXtract\fP (uint8_t conf, uint8_t iface, uint8_t alt, uint8_t proto, const USB_ENDPOINT_DESCRIPTOR *ep)"
.br
.in -1c
.in -1c
.PP
.RI "\fBHCI Commands\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBHCI_Command\fP (uint8_t *\fBdata\fP, uint16_t nbytes)"
.br
.ti -1c
.RI "void \fBhci_reset\fP ()"
.br
.ti -1c
.RI "void \fBhci_read_bdaddr\fP ()"
.br
.ti -1c
.RI "void \fBhci_read_local_version_information\fP ()"
.br
.ti -1c
.RI "void \fBhci_set_local_name\fP (const char *name)"
.br
.ti -1c
.RI "void \fBhci_write_scan_enable\fP ()"
.br
.ti -1c
.RI "void \fBhci_write_scan_disable\fP ()"
.br
.ti -1c
.RI "void \fBhci_remote_name\fP ()"
.br
.ti -1c
.RI "void \fBhci_accept_connection\fP ()"
.br
.ti -1c
.RI "void \fBhci_disconnect\fP (uint16_t handle)"
.br
.ti -1c
.RI "void \fBhci_pin_code_request_reply\fP ()"
.br
.ti -1c
.RI "void \fBhci_pin_code_negative_request_reply\fP ()"
.br
.ti -1c
.RI "void \fBhci_link_key_request_negative_reply\fP ()"
.br
.ti -1c
.RI "void \fBhci_authentication_request\fP ()"
.br
.ti -1c
.RI "void \fBhci_inquiry\fP ()"
.br
.ti -1c
.RI "void \fBhci_inquiry_cancel\fP ()"
.br
.ti -1c
.RI "void \fBhci_connect\fP ()"
.br
.ti -1c
.RI "void \fBhci_connect\fP (uint8_t *bdaddr)"
.br
.ti -1c
.RI "void \fBhci_write_class_of_device\fP ()"
.br
.in -1c
.in -1c
.PP
.RI "\fBL2CAP Commands\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fBL2CAP_Command\fP (uint16_t handle, uint8_t *\fBdata\fP, uint8_t nbytes, uint8_t channelLow=0x01, uint8_t channelHigh=0x00)"
.br
.ti -1c
.RI "void \fBl2cap_connection_request\fP (uint16_t handle, uint8_t rxid, uint8_t *scid, uint16_t psm)"
.br
.ti -1c
.RI "void \fBl2cap_connection_response\fP (uint16_t handle, uint8_t rxid, uint8_t *dcid, uint8_t *scid, uint8_t result)"
.br
.ti -1c
.RI "void \fBl2cap_config_request\fP (uint16_t handle, uint8_t rxid, uint8_t *dcid)"
.br
.ti -1c
.RI "void \fBl2cap_config_response\fP (uint16_t handle, uint8_t rxid, uint8_t *scid)"
.br
.ti -1c
.RI "void \fBl2cap_disconnection_request\fP (uint16_t handle, uint8_t rxid, uint8_t *dcid, uint8_t *scid)"
.br
.ti -1c
.RI "void \fBl2cap_disconnection_response\fP (uint16_t handle, uint8_t rxid, uint8_t *dcid, uint8_t *scid)"
.br
.ti -1c
.RI "void \fBl2cap_information_response\fP (uint16_t handle, uint8_t rxid, uint8_t infoTypeLow, uint8_t infoTypeHigh)"
.br
.in -1c
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBwatingForConnection\fP"
.br
.ti -1c
.RI "bool \fBl2capConnectionClaimed\fP"
.br
.ti -1c
.RI "bool \fBsdpConnectionClaimed\fP"
.br
.ti -1c
.RI "bool \fBrfcommConnectionClaimed\fP"
.br
.ti -1c
.RI "const char * \fBbtdName\fP"
.br
.ti -1c
.RI "const char * \fBbtdPin\fP"
.br
.ti -1c
.RI "uint8_t \fBmy_bdaddr\fP [6]"
.br
.ti -1c
.RI "uint16_t \fBhci_handle\fP"
.br
.ti -1c
.RI "uint8_t \fBdisc_bdaddr\fP [6]"
.br
.ti -1c
.RI "char \fBremote_name\fP [30]"
.br
.ti -1c
.RI "uint8_t \fBhci_version\fP"
.br
.ti -1c
.RI "bool \fBconnectToWii\fP"
.br
.ti -1c
.RI "bool \fBincomingWii\fP"
.br
.ti -1c
.RI "bool \fBpairWithWii\fP"
.br
.ti -1c
.RI "bool \fBmotionPlusInside\fP"
.br
.ti -1c
.RI "bool \fBwiiUProController\fP"
.br
.ti -1c
.RI "bool \fBconnectToHIDDevice\fP"
.br
.ti -1c
.RI "bool \fBincomingHIDDevice\fP"
.br
.ti -1c
.RI "bool \fBpairWithHIDDevice\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBPrintEndpointDescriptor\fP (const USB_ENDPOINT_DESCRIPTOR *ep_ptr)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "USB * \fBpUsb\fP"
.br
.ti -1c
.RI "uint8_t \fBbAddress\fP"
.br
.ti -1c
.RI "EpInfo \fBepInfo\fP [\fBBTD_MAX_ENDPOINTS\fP]"
.br
.ti -1c
.RI "uint8_t \fBbConfNum\fP"
.br
.ti -1c
.RI "uint8_t \fBbNumEP\fP"
.br
.ti -1c
.RI "uint32_t \fBqNextPollTime\fP"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static const uint8_t \fBBTD_CONTROL_PIPE\fP = 0"
.br
.ti -1c
.RI "static const uint8_t \fBBTD_EVENT_PIPE\fP = 1"
.br
.ti -1c
.RI "static const uint8_t \fBBTD_DATAIN_PIPE\fP = 2"
.br
.ti -1c
.RI "static const uint8_t \fBBTD_DATAOUT_PIPE\fP = 3"
.br
.in -1c
.SH "Detailed Description"
.PP 
The Bluetooth Dongle class will take care of all the USB communication and then pass the data to the \fBBluetoothService\fP classes\&. 
.PP
Definition at line 230 of file BTD\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBBTD::BTD\fP (USB *p)"Constructor for the \fBBTD\fP class\&. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP Pointer to USB class instance\&. 
.RE
.PP

.PP
Definition at line 27 of file BTD\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "uint8_t \fBBTD::ConfigureDevice\fP (uint8_tparent, uint8_tport, boollowspeed)\fC [virtual]\fP"Address assignment and basic initialization is done here\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP Hub number\&. 
.br
\fIport\fP Port number on the hub\&. 
.br
\fIlowspeed\fP Speed of the device\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success\&. 
.RE
.PP

.PP
Definition at line 48 of file BTD\&.cpp\&.
.SS "virtual boolean \fBBTD::DEVCLASSOK\fP (uint8_tklass)\fC [inline, virtual]\fP"Used by the USB core to check what this driver support\&. 
.PP
\fBParameters:\fP
.RS 4
\fIklass\fP The device's USB class\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if the device's USB class matches this driver\&. 
.RE
.PP

.PP
Definition at line 287 of file BTD\&.h\&.
.SS "void \fBBTD::disconnect\fP ()\fC [inline]\fP"Disconnects both the L2CAP Channel and the HCI Connection for all Bluetooth services\&. 
.PP
Definition at line 322 of file BTD\&.h\&.
.SS "void \fBBTD::EndpointXtract\fP (uint8_tconf, uint8_tiface, uint8_talt, uint8_tproto, const USB_ENDPOINT_DESCRIPTOR *ep)\fC [virtual]\fP"UsbConfigXtracter implementation, used to extract endpoint information\&. 
.PP
\fBParameters:\fP
.RS 4
\fIconf\fP Configuration value\&. 
.br
\fIiface\fP Interface number\&. 
.br
\fIalt\fP Alternate setting\&. 
.br
\fIproto\fP Interface Protocol\&. 
.br
\fIep\fP Endpoint Descriptor\&. 
.RE
.PP

.PP
Definition at line 314 of file BTD\&.cpp\&.
.SS "virtual uint8_t \fBBTD::GetAddress\fP ()\fC [inline, virtual]\fP"Get the device address\&. 
.PP
\fBReturns:\fP
.RS 4
The device address\&. 
.RE
.PP

.PP
Definition at line 270 of file BTD\&.h\&.
.SS "void \fBBTD::hci_accept_connection\fP ()"Accept the connection with the Bluetooth device\&. 
.PP
Definition at line 973 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_authentication_request\fP ()"Used to try to authenticate with the remote device\&. 
.PP
Definition at line 1132 of file BTD\&.cpp\&.
.SS "void \fBBTD::HCI_Command\fP (uint8_t *data, uint16_tnbytes)"Used to send a HCI Command\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP Data to send\&. 
.br
\fInbytes\fP Number of bytes to send\&. 
.RE
.PP

.PP
Definition at line 919 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_connect\fP ()"Connect to last device communicated with\&. 
.PP
Definition at line 1042 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_connect\fP (uint8_t *bdaddr)"Connect to device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbdaddr\fP Bluetooth address of the device\&. 
.RE
.PP

.PP
Definition at line 1046 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_disconnect\fP (uint16_thandle)"Disconnect the HCI connection\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP The HCI Handle for the connection\&. 
.RE
.PP

.PP
Definition at line 1142 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_inquiry\fP ()"Start a HCI inquiry\&. 
.PP
Definition at line 1020 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_inquiry_cancel\fP ()"Cancel a HCI inquiry\&. 
.PP
Definition at line 1034 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_link_key_request_negative_reply\fP ()"Command is used to reply to a Link Key Request event from the BR/EDR Controller if the Host does not have a stored Link Key for the connection\&. 
.PP
Definition at line 1118 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_pin_code_negative_request_reply\fP ()"Respons when no pin was set\&. 
.PP
Definition at line 1104 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_pin_code_request_reply\fP ()"Respond with the pin for the connection\&. The pin is automatically set for the Wii library, but can be customized for the \fBSPP\fP library\&. 
.PP
Definition at line 1068 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_read_bdaddr\fP ()"Read the Bluetooth address of the dongle\&. 
.PP
Definition at line 955 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_read_local_version_information\fP ()"Read the HCI Version of the Bluetooth dongle\&. 
.PP
Definition at line 964 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_remote_name\fP ()"Read the remote devices name\&. 
.PP
Definition at line 989 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_reset\fP ()"Reset the Bluetooth dongle\&. 
.PP
Definition at line 924 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_set_local_name\fP (const char *name)"Set the local name of the Bluetooth dongle\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP Desired name\&. 
.RE
.PP

.PP
Definition at line 1008 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_write_class_of_device\fP ()"Used to a set the class of the device\&. 
.PP
Definition at line 1154 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_write_scan_disable\fP ()"Disable visibility to other Bluetooth devices\&. 
.PP
Definition at line 946 of file BTD\&.cpp\&.
.SS "void \fBBTD::hci_write_scan_enable\fP ()"Enable visibility to other Bluetooth devices\&. 
.PP
Definition at line 933 of file BTD\&.cpp\&.
.SS "uint8_t \fBBTD::Init\fP (uint8_tparent, uint8_tport, boollowspeed)\fC [virtual]\fP"Initialize the Bluetooth dongle\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP Hub number\&. 
.br
\fIport\fP Port number on the hub\&. 
.br
\fIlowspeed\fP Speed of the device\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success\&. 
.RE
.PP

.PP
Definition at line 122 of file BTD\&.cpp\&.
.SS "virtual bool \fBBTD::isReady\fP ()\fC [inline, virtual]\fP"Used to check if the dongle has been initialized\&. 
.PP
\fBReturns:\fP
.RS 4
True if it's ready\&. 
.RE
.PP

.PP
Definition at line 278 of file BTD\&.h\&.
.SS "void \fBBTD::L2CAP_Command\fP (uint16_thandle, uint8_t *data, uint8_tnbytes, uint8_tchannelLow = \fC0x01\fP, uint8_tchannelHigh = \fC0x00\fP)"Used to send L2CAP Commands\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI Handle\&. 
.br
\fIdata\fP Data to send\&. 
.br
\fInbytes\fP Number of bytes to send\&. 
.br
\fIchannelLow,channelHigh\fP Low and high byte of channel to send to\&. If argument is omitted then the Standard L2CAP header: Channel ID (0x01) for ACL-U will be used\&. 
.RE
.PP

.PP
Definition at line 1190 of file BTD\&.cpp\&.
.SS "void \fBBTD::l2cap_config_request\fP (uint16_thandle, uint8_trxid, uint8_t *dcid)"L2CAP Config Request\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI Handle\&. 
.br
\fIrxid\fP Identifier\&. 
.br
\fIdcid\fP Destination Channel Identifier\&. 
.RE
.PP

.PP
Definition at line 1248 of file BTD\&.cpp\&.
.SS "void \fBBTD::l2cap_config_response\fP (uint16_thandle, uint8_trxid, uint8_t *scid)"L2CAP Config Response\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI Handle\&. 
.br
\fIrxid\fP Identifier\&. 
.br
\fIscid\fP Source Channel Identifier\&. 
.RE
.PP

.PP
Definition at line 1265 of file BTD\&.cpp\&.
.SS "void \fBBTD::l2cap_connection_request\fP (uint16_thandle, uint8_trxid, uint8_t *scid, uint16_tpsm)"L2CAP Connection Request\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI handle\&. 
.br
\fIrxid\fP Identifier\&. 
.br
\fIscid\fP Source Channel Identifier\&. 
.br
\fIpsm\fP Protocol/Service Multiplexer - see: https://www.bluetooth.org/Technical/AssignedNumbers/logical_link.htm\&. 
.RE
.PP

.PP
Definition at line 1218 of file BTD\&.cpp\&.
.SS "void \fBBTD::l2cap_connection_response\fP (uint16_thandle, uint8_trxid, uint8_t *dcid, uint8_t *scid, uint8_tresult)"L2CAP Connection Response\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI handle\&. 
.br
\fIrxid\fP Identifier\&. 
.br
\fIdcid\fP Destination Channel Identifier\&. 
.br
\fIscid\fP Source Channel Identifier\&. 
.br
\fIresult\fP Result - First send \fBPENDING\fP and then \fBSUCCESSFUL\fP\&. 
.RE
.PP

.PP
Definition at line 1231 of file BTD\&.cpp\&.
.SS "void \fBBTD::l2cap_disconnection_request\fP (uint16_thandle, uint8_trxid, uint8_t *dcid, uint8_t *scid)"L2CAP Disconnection Request\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI Handle\&. 
.br
\fIrxid\fP Identifier\&. 
.br
\fIdcid\fP Device Channel Identifier\&. 
.br
\fIscid\fP Source Channel Identifier\&. 
.RE
.PP

.PP
Definition at line 1284 of file BTD\&.cpp\&.
.SS "void \fBBTD::l2cap_disconnection_response\fP (uint16_thandle, uint8_trxid, uint8_t *dcid, uint8_t *scid)"L2CAP Disconnection Response\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI Handle\&. 
.br
\fIrxid\fP Identifier\&. 
.br
\fIdcid\fP Device Channel Identifier\&. 
.br
\fIscid\fP Source Channel Identifier\&. 
.RE
.PP

.PP
Definition at line 1297 of file BTD\&.cpp\&.
.SS "void \fBBTD::l2cap_information_response\fP (uint16_thandle, uint8_trxid, uint8_tinfoTypeLow, uint8_tinfoTypeHigh)"L2CAP Information Response\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP HCI Handle\&. 
.br
\fIrxid\fP Identifier\&. 
.br
\fIinfoTypeLow,infoTypeHigh\fP Infotype\&. 
.RE
.PP

.PP
Definition at line 1310 of file BTD\&.cpp\&.
.SS "void \fBBTD::pairWithHID\fP ()\fC [inline]\fP"Call this function to pair with a Wiimote 
.PP
Definition at line 516 of file BTD\&.h\&.
.SS "void \fBBTD::pairWithWiimote\fP ()\fC [inline]\fP"Call this function to pair with a Wiimote 
.PP
Definition at line 500 of file BTD\&.h\&.
.SS "uint8_t \fBBTD::Poll\fP ()\fC [virtual]\fP"Poll the USB Input endpoints and run the state machines\&. 
.PP
\fBReturns:\fP
.RS 4
0 on success\&. 
.RE
.PP

.PP
Definition at line 371 of file BTD\&.cpp\&.
.SS "void \fBBTD::PrintEndpointDescriptor\fP (const USB_ENDPOINT_DESCRIPTOR *ep_ptr)\fC [protected]\fP"Used to print the USB Endpoint Descriptor\&. 
.PP
\fBParameters:\fP
.RS 4
\fIep_ptr\fP Pointer to USB Endpoint Descriptor\&. 
.RE
.PP

.PP
Definition at line 346 of file BTD\&.cpp\&.
.SS "uint8_t \fBBTD::readPollInterval\fP ()\fC [inline]\fP"Read the poll interval taken from the endpoint descriptors\&. 
.PP
\fBReturns:\fP
.RS 4
The poll interval in ms\&. 
.RE
.PP

.PP
Definition at line 531 of file BTD\&.h\&.
.SS "int8_t \fBBTD::registerServiceClass\fP (\fBBluetoothService\fP *pService)\fC [inline]\fP"Register Bluetooth dongle members/services\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpService\fP Pointer to \fBBluetoothService\fP class instance\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The service ID on success or -1 on fail\&. 
.RE
.PP

.PP
Definition at line 333 of file BTD\&.h\&.
.SS "uint8_t \fBBTD::Release\fP ()\fC [virtual]\fP"Release the USB device\&. 
.PP
\fBReturns:\fP
.RS 4
0 on success\&. 
.RE
.PP

.PP
Definition at line 365 of file BTD\&.cpp\&.
.SS "virtual boolean \fBBTD::VIDPIDOK\fP (uint16_tvid, uint16_tpid)\fC [inline, virtual]\fP"Used by the USB core to check what this driver support\&. Used to set the Bluetooth address into the PS3 controllers\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvid\fP The device's VID\&. 
.br
\fIpid\fP The device's PID\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if the device's VID and PID matches this driver\&. 
.RE
.PP

.PP
Definition at line 298 of file BTD\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "uint8_t \fBBTD::bAddress\fP\fC [protected]\fP"Device address\&. 
.PP
Definition at line 539 of file BTD\&.h\&.
.SS "uint8_t \fBBTD::bConfNum\fP\fC [protected]\fP"Configuration number\&. 
.PP
Definition at line 544 of file BTD\&.h\&.
.SS "uint8_t \fBBTD::bNumEP\fP\fC [protected]\fP"Total number of endpoints in the configuration\&. 
.PP
Definition at line 546 of file BTD\&.h\&.
.SS "const uint8_t \fBBTD::BTD_CONTROL_PIPE\fP = 0\fC [static, protected]\fP"Bluetooth dongle control endpoint\&. 
.PP
Definition at line 551 of file BTD\&.h\&.
.SS "const uint8_t \fBBTD::BTD_DATAIN_PIPE\fP = 2\fC [static, protected]\fP"ACL In endpoint index\&. 
.PP
Definition at line 555 of file BTD\&.h\&.
.SS "const uint8_t \fBBTD::BTD_DATAOUT_PIPE\fP = 3\fC [static, protected]\fP"ACL Out endpoint index\&. 
.PP
Definition at line 557 of file BTD\&.h\&.
.SS "const uint8_t \fBBTD::BTD_EVENT_PIPE\fP = 1\fC [static, protected]\fP"HCI event endpoint index\&. 
.PP
Definition at line 553 of file BTD\&.h\&.
.SS "const char* \fBBTD::btdName\fP"The name you wish to make the dongle show up as\&. It is set automatically by the \fBSPP\fP library\&. 
.PP
Definition at line 480 of file BTD\&.h\&.
.SS "const char* \fBBTD::btdPin\fP"The pin you wish to make the dongle use for authentication\&. It is set automatically by the \fBSPP\fP and \fBBTHID\fP library\&. 
.PP
Definition at line 482 of file BTD\&.h\&.
.SS "bool \fBBTD::connectToHIDDevice\fP"Used to only send the ACL data to the Wiimote\&. 
.PP
Definition at line 519 of file BTD\&.h\&.
.SS "bool \fBBTD::connectToWii\fP"Used to only send the ACL data to the Wiimote\&. 
.PP
Definition at line 503 of file BTD\&.h\&.
.SS "uint8_t \fBBTD::disc_bdaddr\fP[6]"Last incoming devices Bluetooth address\&. 
.PP
Definition at line 489 of file BTD\&.h\&.
.SS "EpInfo \fBBTD::epInfo\fP[\fBBTD_MAX_ENDPOINTS\fP]\fC [protected]\fP"Endpoint info structure\&. 
.PP
Definition at line 541 of file BTD\&.h\&.
.SS "uint16_t \fBBTD::hci_handle\fP"HCI handle for the last connection\&. 
.PP
Definition at line 487 of file BTD\&.h\&.
.SS "uint8_t \fBBTD::hci_version\fP"The supported HCI Version read from the Bluetooth dongle\&. Used by the \fBPS3BT\fP library to check the HCI Version of the Bluetooth dongle, it should be at least 3 to work properly with the library\&. 
.PP
Definition at line 497 of file BTD\&.h\&.
.SS "bool \fBBTD::incomingHIDDevice\fP"True if a Wiimote is connecting\&. 
.PP
Definition at line 523 of file BTD\&.h\&.
.SS "bool \fBBTD::incomingWii\fP"True if a Wiimote is connecting\&. 
.PP
Definition at line 507 of file BTD\&.h\&.
.SS "bool \fBBTD::l2capConnectionClaimed\fP"This is used by the service to know when to store the device information\&. 
.PP
Definition at line 473 of file BTD\&.h\&.
.SS "bool \fBBTD::motionPlusInside\fP"True if it's the new Wiimote with the Motion Plus Inside or a Wii U Pro Controller\&. 
.PP
Definition at line 511 of file BTD\&.h\&.
.SS "uint8_t \fBBTD::my_bdaddr\fP[6]"The bluetooth dongles Bluetooth address\&. 
.PP
Definition at line 485 of file BTD\&.h\&.
.SS "bool \fBBTD::pairWithHIDDevice\fP"True when it should pair with a device like a mouse or keyboard\&. 
.PP
Definition at line 525 of file BTD\&.h\&.
.SS "bool \fBBTD::pairWithWii\fP"True when it should pair with a Wiimote\&. 
.PP
Definition at line 509 of file BTD\&.h\&.
.SS "USB* \fBBTD::pUsb\fP\fC [protected]\fP"Pointer to USB class instance\&. 
.PP
Definition at line 533 of file BTD\&.h\&.
.SS "uint32_t \fBBTD::qNextPollTime\fP\fC [protected]\fP"Next poll time based on poll interval taken from the USB descriptor\&. 
.PP
Definition at line 548 of file BTD\&.h\&.
.SS "char \fBBTD::remote_name\fP[30]"First 30 chars of last remote name\&. 
.PP
Definition at line 491 of file BTD\&.h\&.
.SS "bool \fBBTD::rfcommConnectionClaimed\fP"This is used by the \fBSPP\fP library to claim the current RFCOMM incoming request\&. 
.PP
Definition at line 477 of file BTD\&.h\&.
.SS "bool \fBBTD::sdpConnectionClaimed\fP"This is used by the \fBSPP\fP library to claim the current SDP incoming request\&. 
.PP
Definition at line 475 of file BTD\&.h\&.
.SS "bool \fBBTD::watingForConnection\fP"Use this to see if it is waiting for a incoming connection\&. 
.PP
Definition at line 471 of file BTD\&.h\&.
.SS "bool \fBBTD::wiiUProController\fP"True if it's a Wii U Pro Controller\&. 
.PP
Definition at line 513 of file BTD\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for GHID Framework from the source code\&.
