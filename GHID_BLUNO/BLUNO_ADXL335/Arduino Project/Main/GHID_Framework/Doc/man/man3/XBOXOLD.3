.TH "XBOXOLD" 3 "Sun Mar 30 2014" "Version version 2.0" "GHID Framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
XBOXOLD \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <XBOXOLD\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBXBOXOLD\fP (USB *\fBpUsb\fP)"
.br
.in -1c
.PP
.RI "\fBUSBDeviceConfig implementation\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "virtual uint8_t \fBInit\fP (uint8_t parent, uint8_t port, bool lowspeed)"
.br
.ti -1c
.RI "virtual uint8_t \fBRelease\fP ()"
.br
.ti -1c
.RI "virtual uint8_t \fBPoll\fP ()"
.br
.ti -1c
.RI "virtual uint8_t \fBGetAddress\fP ()"
.br
.ti -1c
.RI "virtual bool \fBisReady\fP ()"
.br
.ti -1c
.RI "virtual boolean \fBVIDPIDOK\fP (uint16_t vid, uint16_t pid)"
.br
.in -1c
.in -1c
.PP
.RI "\fBXbox Controller functions\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "uint8_t \fBgetButtonPress\fP (\fBButtonEnum\fP \fBb\fP)"
.br
.ti -1c
.RI "bool \fBgetButtonClick\fP (\fBButtonEnum\fP \fBb\fP)"
.br
.ti -1c
.RI "int16_t \fBgetAnalogHat\fP (\fBAnalogHatEnum\fP a)"
.br
.ti -1c
.RI "void \fBsetRumbleOff\fP ()"
.br
.ti -1c
.RI "void \fBsetRumbleOn\fP (uint8_t lValue, uint8_t rValue)"
.br
.ti -1c
.RI "void \fBattachOnInit\fP (void(*funcOnInit)(void))"
.br
.in -1c
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "bool \fBXboxConnected\fP"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "USB * \fBpUsb\fP"
.br
.ti -1c
.RI "uint8_t \fBbAddress\fP"
.br
.ti -1c
.RI "EpInfo \fBepInfo\fP [\fBXBOX_MAX_ENDPOINTS\fP]"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class implements support for a the original Xbox controller via USB\&. 
.PP
Definition at line 52 of file XBOXOLD\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBXBOXOLD::XBOXOLD\fP (USB *pUsb)"Constructor for the \fBXBOXOLD\fP class\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpUsb\fP Pointer to USB class instance\&. 
.RE
.PP

.PP
Definition at line 47 of file XBOXOLD\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "void \fBXBOXOLD::attachOnInit\fP (void(*)(void)funcOnInit)\fC [inline]\fP"Used to call your own function when the controller is successfully initialized\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfuncOnInit\fP Function to call\&. 
.RE
.PP

.PP
Definition at line 145 of file XBOXOLD\&.h\&.
.SS "virtual uint8_t \fBXBOXOLD::GetAddress\fP ()\fC [inline, virtual]\fP"Get the device address\&. 
.PP
\fBReturns:\fP
.RS 4
The device address\&. 
.RE
.PP

.PP
Definition at line 84 of file XBOXOLD\&.h\&.
.SS "int16_t \fBXBOXOLD::getAnalogHat\fP (\fBAnalogHatEnum\fPa)"Return the analog value from the joysticks on the controller\&. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP Either \fBLeftHatX\fP, \fBLeftHatY\fP, \fBRightHatX\fP or \fBRightHatY\fP\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a signed 16-bit integer\&. 
.RE
.PP

.PP
Definition at line 316 of file XBOXOLD\&.cpp\&.
.SS "bool \fBXBOXOLD::getButtonClick\fP (\fBButtonEnum\fPb)"
.PP
Definition at line 301 of file XBOXOLD\&.cpp\&.
.SS "uint8_t \fBXBOXOLD::getButtonPress\fP (\fBButtonEnum\fPb)"\fBgetButtonPress(ButtonEnum b)\fP will return true as long as the button is held down\&.
.PP
While \fBgetButtonClick(ButtonEnum b)\fP will only return it once\&.
.PP
So you instance if you need to increase a variable once you would use \fBgetButtonClick(ButtonEnum b)\fP, but if you need to drive a robot forward you would use \fBgetButtonPress(ButtonEnum b)\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIb\fP \fBButtonEnum\fP to read\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBgetButtonClick(ButtonEnum b)\fP will return a bool, while \fBgetButtonPress(ButtonEnum b)\fP will return a byte if reading \fBL2\fP or \fBR2\fP\&. 
.RE
.PP

.PP
Definition at line 294 of file XBOXOLD\&.cpp\&.
.SS "uint8_t \fBXBOXOLD::Init\fP (uint8_tparent, uint8_tport, boollowspeed)\fC [virtual]\fP"Initialize the Xbox Controller\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP Hub number\&. 
.br
\fIport\fP Port number on the hub\&. 
.br
\fIlowspeed\fP Speed of the device\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success\&. 
.RE
.PP

.PP
Definition at line 62 of file XBOXOLD\&.cpp\&.
.SS "virtual bool \fBXBOXOLD::isReady\fP ()\fC [inline, virtual]\fP"Used to check if the controller has been initialized\&. 
.PP
\fBReturns:\fP
.RS 4
True if it's ready\&. 
.RE
.PP

.PP
Definition at line 92 of file XBOXOLD\&.h\&.
.SS "uint8_t \fBXBOXOLD::Poll\fP ()\fC [virtual]\fP"Poll the USB Input endpoins and run the state machines\&. 
.PP
\fBReturns:\fP
.RS 4
0 on success\&. 
.RE
.PP

.PP
Definition at line 244 of file XBOXOLD\&.cpp\&.
.SS "uint8_t \fBXBOXOLD::Release\fP ()\fC [virtual]\fP"Release the USB device\&. 
.PP
\fBReturns:\fP
.RS 4
0 on success\&. 
.RE
.PP

.PP
Definition at line 236 of file XBOXOLD\&.cpp\&.
.SS "void \fBXBOXOLD::setRumbleOff\fP ()\fC [inline]\fP"Turn rumble off the controller\&. 
.PP
Definition at line 131 of file XBOXOLD\&.h\&.
.SS "void \fBXBOXOLD::setRumbleOn\fP (uint8_tlValue, uint8_trValue)"Turn rumble on\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlValue\fP Left motor (big weight) inside the controller\&. 
.br
\fIrValue\fP Right motor (small weight) inside the controller\&. 
.RE
.PP

.PP
Definition at line 326 of file XBOXOLD\&.cpp\&.
.SS "virtual boolean \fBXBOXOLD::VIDPIDOK\fP (uint16_tvid, uint16_tpid)\fC [inline, virtual]\fP"Used by the USB core to check what this driver support\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvid\fP The device's VID\&. 
.br
\fIpid\fP The device's PID\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns true if the device's VID and PID matches this driver\&. 
.RE
.PP

.PP
Definition at line 102 of file XBOXOLD\&.h\&.
.SH "Member Data Documentation"
.PP 
.SS "uint8_t \fBXBOXOLD::bAddress\fP\fC [protected]\fP"Device address\&. 
.PP
Definition at line 157 of file XBOXOLD\&.h\&.
.SS "EpInfo \fBXBOXOLD::epInfo\fP[\fBXBOX_MAX_ENDPOINTS\fP]\fC [protected]\fP"Endpoint info structure\&. 
.PP
Definition at line 159 of file XBOXOLD\&.h\&.
.SS "USB* \fBXBOXOLD::pUsb\fP\fC [protected]\fP"Pointer to USB class instance\&. 
.PP
Definition at line 155 of file XBOXOLD\&.h\&.
.SS "bool \fBXBOXOLD::XboxConnected\fP"True if a Xbox controller is connected\&. 
.PP
Definition at line 147 of file XBOXOLD\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for GHID Framework from the source code\&.
