.TH "BulkOnly" 3 "Sun Mar 30 2014" "Version version 2.0" "GHID Framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
BulkOnly \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <masstorage\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBBulkOnly\fP (USB *p)"
.br
.ti -1c
.RI "uint8_t \fBGetLastUsbError\fP ()"
.br
.ti -1c
.RI "uint8_t \fBGetbMaxLUN\fP ()"
.br
.ti -1c
.RI "uint8_t \fBGetbTheLUN\fP ()"
.br
.ti -1c
.RI "boolean \fBWriteProtected\fP (uint8_t lun)"
.br
.ti -1c
.RI "uint8_t \fBMediaCTL\fP (uint8_t lun, uint8_t ctl)"
.br
.ti -1c
.RI "uint8_t \fBRead\fP (uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, uint8_t *buf)"
.br
.ti -1c
.RI "uint8_t \fBRead\fP (uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, USBReadParser *prs)"
.br
.ti -1c
.RI "uint8_t \fBWrite\fP (uint8_t lun, uint32_t addr, uint16_t bsize, uint8_t blocks, const uint8_t *buf)"
.br
.ti -1c
.RI "uint8_t \fBLockMedia\fP (uint8_t lun, uint8_t lock)"
.br
.ti -1c
.RI "bool \fBLUNIsGood\fP (uint8_t lun)"
.br
.ti -1c
.RI "uint32_t \fBGetCapacity\fP (uint8_t lun)"
.br
.ti -1c
.RI "uint16_t \fBGetSectorSize\fP (uint8_t lun)"
.br
.ti -1c
.RI "virtual uint8_t \fBInit\fP (uint8_t parent, uint8_t port, bool lowspeed)"
.br
.ti -1c
.RI "virtual uint8_t \fBConfigureDevice\fP (uint8_t parent, uint8_t port, bool lowspeed)"
.br
.ti -1c
.RI "virtual uint8_t \fBRelease\fP ()"
.br
.ti -1c
.RI "virtual uint8_t \fBPoll\fP ()"
.br
.ti -1c
.RI "virtual uint8_t \fBGetAddress\fP ()"
.br
.ti -1c
.RI "virtual void \fBEndpointXtract\fP (uint8_t conf, uint8_t iface, uint8_t alt, uint8_t proto, const USB_ENDPOINT_DESCRIPTOR *ep)"
.br
.ti -1c
.RI "virtual boolean \fBDEVCLASSOK\fP (uint8_t klass)"
.br
.ti -1c
.RI "uint8_t \fBSCSITransaction6\fP (\fBCDB6_t\fP *cdb, uint16_t buf_size, void *buf, uint8_t dir)"
.br
.ti -1c
.RI "uint8_t \fBSCSITransaction10\fP (\fBCDB10_t\fP *cdb, uint16_t buf_size, void *buf, uint8_t dir)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBPrintEndpointDescriptor\fP (const USB_ENDPOINT_DESCRIPTOR *ep_ptr)"
.br
.ti -1c
.RI "virtual uint8_t \fBOnInit\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "USB * \fBpUsb\fP"
.br
.ti -1c
.RI "uint8_t \fBbAddress\fP"
.br
.ti -1c
.RI "uint8_t \fBbConfNum\fP"
.br
.ti -1c
.RI "uint8_t \fBbIface\fP"
.br
.ti -1c
.RI "uint8_t \fBbNumEP\fP"
.br
.ti -1c
.RI "uint32_t \fBqNextPollTime\fP"
.br
.ti -1c
.RI "bool \fBbPollEnable\fP"
.br
.ti -1c
.RI "EpInfo \fBepInfo\fP [\fBMASS_MAX_ENDPOINTS\fP]"
.br
.ti -1c
.RI "uint32_t \fBdCBWTag\fP"
.br
.ti -1c
.RI "uint8_t \fBbLastUsbError\fP"
.br
.ti -1c
.RI "uint8_t \fBbMaxLUN\fP"
.br
.ti -1c
.RI "uint8_t \fBbTheLUN\fP"
.br
.ti -1c
.RI "uint32_t \fBCurrentCapacity\fP [MASS_MAX_SUPPORTED_LUN]"
.br
.ti -1c
.RI "uint16_t \fBCurrentSectorSize\fP [MASS_MAX_SUPPORTED_LUN]"
.br
.ti -1c
.RI "bool \fBLUNOk\fP [MASS_MAX_SUPPORTED_LUN]"
.br
.ti -1c
.RI "bool \fBWriteOk\fP [MASS_MAX_SUPPORTED_LUN]"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static const uint8_t \fBepDataInIndex\fP = 1"
.br
.ti -1c
.RI "static const uint8_t \fBepDataOutIndex\fP = 2"
.br
.ti -1c
.RI "static const uint8_t \fBepInterruptInIndex\fP = 3"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line 462 of file masstorage\&.h\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBBulkOnly::BulkOnly\fP (USB *p)"
.PP
Definition at line 222 of file masstorage\&.cpp\&.
.SH "Member Function Documentation"
.PP 
.SS "uint8_t \fBBulkOnly::ConfigureDevice\fP (uint8_tparent, uint8_tport, boollowspeed)\fC [virtual]\fP"USB_ERROR_CONFIG_REQUIRES_ADDITIONAL_RESET == success We need to standardize either the rcode, or change the API to return values so a signal that additional actions are required can be produced\&. Some of these codes do exist already\&.
.PP
TECHNICAL: We could do most of this code elsewhere, with the exception of checking the class instance\&. Doing so would save some program memory when using multiple drivers\&.
.PP
\fBParameters:\fP
.RS 4
\fIparent\fP USB address of parent 
.br
\fIport\fP address of port on parent 
.br
\fIlowspeed\fP true if device is low speed 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 251 of file masstorage\&.cpp\&.
.SS "virtual boolean \fBBulkOnly::DEVCLASSOK\fP (uint8_tklass)\fC [inline, virtual]\fP"
.PP
Definition at line 535 of file masstorage\&.h\&.
.SS "void \fBBulkOnly::EndpointXtract\fP (uint8_tconf, uint8_tiface, uint8_talt, uint8_tproto, const USB_ENDPOINT_DESCRIPTOR *pep)\fC [virtual]\fP"For driver use only\&.
.PP
\fBParameters:\fP
.RS 4
\fIconf\fP 
.br
\fIiface\fP 
.br
\fIalt\fP 
.br
\fIproto\fP 
.br
\fIpep\fP 
.RE
.PP

.PP
Definition at line 543 of file masstorage\&.cpp\&.
.SS "virtual uint8_t \fBBulkOnly::GetAddress\fP ()\fC [inline, virtual]\fP"
.PP
Definition at line 528 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::GetbMaxLUN\fP ()\fC [inline]\fP"
.PP
Definition at line 502 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::GetbTheLUN\fP ()\fC [inline]\fP"
.PP
Definition at line 506 of file masstorage\&.h\&.
.SS "uint32_t \fBBulkOnly::GetCapacity\fP (uint8_tlun)"Get the capacity of the media
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.RE
.PP
\fBReturns:\fP
.RS 4
media capacity 
.RE
.PP

.PP
Definition at line 36 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::GetLastUsbError\fP ()\fC [inline]\fP"
.PP
Definition at line 498 of file masstorage\&.h\&.
.SS "uint16_t \fBBulkOnly::GetSectorSize\fP (uint8_tlun)"Get the sector (block) size used on the media
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.RE
.PP
\fBReturns:\fP
.RS 4
media sector size 
.RE
.PP

.PP
Definition at line 48 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::Init\fP (uint8_tparent, uint8_tport, boollowspeed)\fC [virtual]\fP"\fBParameters:\fP
.RS 4
\fIparent\fP (not used) 
.br
\fIport\fP (not used) 
.br
\fIlowspeed\fP true if device is low speed 
.RE
.PP
\fBReturns:\fP
.RS 4
0 for success 
.RE
.PP

.PP
Definition at line 326 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::LockMedia\fP (uint8_tlun, uint8_tlock)"Lock or Unlock the tray or door on device\&. Caution: Some devices with buggy firmware will lock up\&.
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.br
\fIlock\fP 1 to lock, 0 to unlock 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 114 of file masstorage\&.cpp\&.
.SS "bool \fBBulkOnly::LUNIsGood\fP (uint8_tlun)"Test if LUN is ready for use
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.RE
.PP
\fBReturns:\fP
.RS 4
true if LUN is ready for use 
.RE
.PP

.PP
Definition at line 60 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::MediaCTL\fP (uint8_tlun, uint8_tctl)"Media control, for spindle motor and media tray or door\&. This includes CDROM, TAPE and anything with a media loader\&.
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.br
\fIctl\fP 0x00 Stop Motor, 0x01 Start Motor, 0x02 Eject Media, 0x03 Load Media 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success 
.RE
.PP

.PP
Definition at line 130 of file masstorage\&.cpp\&.
.SS "virtual uint8_t \fBBulkOnly::OnInit\fP ()\fC [inline, protected, virtual]\fP"
.PP
Definition at line 492 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::Poll\fP ()\fC [virtual]\fP"For driver use only\&.
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 653 of file masstorage\&.cpp\&.
.SS "void \fBBulkOnly::PrintEndpointDescriptor\fP (const USB_ENDPOINT_DESCRIPTOR *ep_ptr)\fC [protected]\fP"\fBParameters:\fP
.RS 4
\fIep_ptr\fP 
.RE
.PP

.PP
Definition at line 1198 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::Read\fP (uint8_tlun, uint32_taddr, uint16_tbsize, uint8_tblocks, uint8_t *buf)"Read data from media
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.br
\fIaddr\fP LBA address on media to read 
.br
\fIbsize\fP size of a block (we should probably use the cached size) 
.br
\fIblocks\fP how many blocks to read 
.br
\fIbuf\fP memory that is able to hold the requested data 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success 
.RE
.PP

.PP
Definition at line 154 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::Read\fP (uint8_tlun, uint32_taddr, uint16_tbsize, uint8_tblocks, USBReadParser *prs)"
.PP
Definition at line 1225 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::Release\fP ()\fC [virtual]\fP"For driver use only\&.
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 575 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::SCSITransaction10\fP (\fBCDB10_t\fP *cdb, uint16_tbuf_size, void *buf, uint8_tdir)"Wrap and execute a SCSI CDB with length of 10
.PP
\fBParameters:\fP
.RS 4
\fIcdb\fP CDB to execute 
.br
\fIbuf_size\fP Size of expected transaction 
.br
\fIbuf\fP Buffer 
.br
\fIdir\fP MASS_CMD_DIR_IN | MASS_CMD_DIR_OUT 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 99 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::SCSITransaction6\fP (\fBCDB6_t\fP *cdb, uint16_tbuf_size, void *buf, uint8_tdir)"Wrap and execute a SCSI CDB with length of 6
.PP
\fBParameters:\fP
.RS 4
\fIcdb\fP CDB to execute 
.br
\fIbuf_size\fP Size of expected transaction 
.br
\fIbuf\fP Buffer 
.br
\fIdir\fP MASS_CMD_DIR_IN | MASS_CMD_DIR_OUT 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 83 of file masstorage\&.cpp\&.
.SS "uint8_t \fBBulkOnly::Write\fP (uint8_tlun, uint32_taddr, uint16_tbsize, uint8_tblocks, const uint8_t *buf)"Write data to media
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.br
\fIaddr\fP LBA address on media to write 
.br
\fIbsize\fP size of a block (we should probably use the cached size) 
.br
\fIblocks\fP how many blocks to write 
.br
\fIbuf\fP memory that contains the data to write 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success 
.RE
.PP

.PP
Definition at line 188 of file masstorage\&.cpp\&.
.SS "boolean \fBBulkOnly::WriteProtected\fP (uint8_tlun)"Test if LUN is write protected
.PP
\fBParameters:\fP
.RS 4
\fIlun\fP Logical Unit Number 
.RE
.PP
\fBReturns:\fP
.RS 4
cached status of write protect switch 
.RE
.PP

.PP
Definition at line 70 of file masstorage\&.cpp\&.
.SH "Member Data Documentation"
.PP 
.SS "uint8_t \fBBulkOnly::bAddress\fP\fC [protected]\fP"
.PP
Definition at line 469 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::bConfNum\fP\fC [protected]\fP"
.PP
Definition at line 470 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::bIface\fP\fC [protected]\fP"
.PP
Definition at line 471 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::bLastUsbError\fP\fC [protected]\fP"
.PP
Definition at line 480 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::bMaxLUN\fP\fC [protected]\fP"
.PP
Definition at line 481 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::bNumEP\fP\fC [protected]\fP"
.PP
Definition at line 472 of file masstorage\&.h\&.
.SS "bool \fBBulkOnly::bPollEnable\fP\fC [protected]\fP"
.PP
Definition at line 474 of file masstorage\&.h\&.
.SS "uint8_t \fBBulkOnly::bTheLUN\fP\fC [protected]\fP"
.PP
Definition at line 482 of file masstorage\&.h\&.
.SS "uint32_t \fBBulkOnly::CurrentCapacity\fP[MASS_MAX_SUPPORTED_LUN]\fC [protected]\fP"
.PP
Definition at line 483 of file masstorage\&.h\&.
.SS "uint16_t \fBBulkOnly::CurrentSectorSize\fP[MASS_MAX_SUPPORTED_LUN]\fC [protected]\fP"
.PP
Definition at line 484 of file masstorage\&.h\&.
.SS "uint32_t \fBBulkOnly::dCBWTag\fP\fC [protected]\fP"
.PP
Definition at line 478 of file masstorage\&.h\&.
.SS "const uint8_t \fBBulkOnly::epDataInIndex\fP = 1\fC [static, protected]\fP"
.PP
Definition at line 464 of file masstorage\&.h\&.
.SS "const uint8_t \fBBulkOnly::epDataOutIndex\fP = 2\fC [static, protected]\fP"
.PP
Definition at line 465 of file masstorage\&.h\&.
.SS "EpInfo \fBBulkOnly::epInfo\fP[\fBMASS_MAX_ENDPOINTS\fP]\fC [protected]\fP"
.PP
Definition at line 476 of file masstorage\&.h\&.
.SS "const uint8_t \fBBulkOnly::epInterruptInIndex\fP = 3\fC [static, protected]\fP"
.PP
Definition at line 466 of file masstorage\&.h\&.
.SS "bool \fBBulkOnly::LUNOk\fP[MASS_MAX_SUPPORTED_LUN]\fC [protected]\fP"
.PP
Definition at line 485 of file masstorage\&.h\&.
.SS "USB* \fBBulkOnly::pUsb\fP\fC [protected]\fP"
.PP
Definition at line 468 of file masstorage\&.h\&.
.SS "uint32_t \fBBulkOnly::qNextPollTime\fP\fC [protected]\fP"
.PP
Definition at line 473 of file masstorage\&.h\&.
.SS "bool \fBBulkOnly::WriteOk\fP[MASS_MAX_SUPPORTED_LUN]\fC [protected]\fP"
.PP
Definition at line 486 of file masstorage\&.h\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for GHID Framework from the source code\&.
